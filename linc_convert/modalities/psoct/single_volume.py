"""
Matlab to OME-Zarr.

Converts Matlab files generated by the MGH in-house OCT pipeline
into a OME-ZARR pyramid.
"""

import json
import logging
import os
from functools import wraps
from typing import Callable, Optional

import cyclopts
import h5py
import numpy as np
from niizarr import write_ome_metadata, default_nifti_header, write_nifti_header

from linc_convert import utils
from linc_convert.modalities.psoct.utils._array_wrapper import _ArrayWrapper, _MatArrayWrapper
from linc_convert.modalities.psoct.utils._utils import make_json
from linc_convert.modalities.psoct.cli import psoct
from linc_convert.modalities.psoct.ms_dask import _H5ArrayWrapper
from linc_convert.utils.chunk_processing import chunk_slice_generator
from linc_convert.utils.math import ceildiv
from linc_convert.utils.orientation import center_affine, orientation_to_affine
from linc_convert.utils.unit import to_nifti_unit, to_ome_unit
from linc_convert.utils.zarr import generate_pyramid, create_array, open_zarr_group
from linc_convert.utils.zarr.zarr_config import ZarrConfig

logger = logging.getLogger(__name__)
single_volume = cyclopts.App(name="single_volume", help_format="markdown")
psoct.command(single_volume)


def _automap(func: Callable) -> Callable:
    """Automatically map the array in the mat file."""

    @wraps(func)
    def wrapper(inp: str, zarr_config: ZarrConfig = None, **kwargs: dict) -> None:
        # with _mapmat(inp, kwargs.get("key", None)) as dat:
        #     return func(dat, zarr_config=zarr_config, **kwargs)
        dat = _mapmat(inp, kwargs.get("key", None))
        return func(dat, **kwargs)

    return wrapper


def _mapmat(fname: str, key: Optional[str] = None) -> _ArrayWrapper:
    """Load or memory-map an array stored in a .mat file."""
    def make_wrapper(fname: str) -> _ArrayWrapper:
        try:
            # "New" .mat file
            f = h5py.File(fname, "r")
            return _H5ArrayWrapper(f, key)
        except Exception:
            # "Old" .mat file
            return _MatArrayWrapper(fname, key)

    return make_wrapper(fname)


@single_volume.default
@_automap
def convert(
    inp: str,
    *,
    key: Optional[str] = None,
    meta: str = None,
    no_pool: Optional[int] = None,
    orientation: str = "RAS",
    center: bool = True,
    zarr_config: ZarrConfig = None,
    **kwargs
) -> None:
    """
    Matlab to OME-Zarr.

    Convert OCT volumes in raw matlab files
    into a pyramidal OME-ZARR (or NIfTI-Zarr) hierarchy.

    Parameters
    ----------
    inp
        Path to the input mat file
    key
        Key of the array to be extracted, default to first key found
    meta
        Path to the metadata file
    chunk
        Output chunk size
    compressor : {blosc, zlib, raw}
        Compression method
    compressor_opt
        Compression options
    max_load
        Maximum input chunk size
    max_levels
        Maximum number of pyramid levels
    no_pool
        Index of dimension to not pool when building pyramid
    nii
        Convert to nifti-zarr. True if path ends in ".nii.zarr"
    orientation
        Orientation of the volume
    center
        Set RAS[0, 0, 0] at FOV center
    """
    zarr_config = utils.zarr.zarr_config.update(zarr_config, **kwargs)
    zarr_config.set_default_name(os.path.splitext(inp.file)[0])

    # Process metadata if provided
    if meta:
        logger.info("Writing JSON metadata")
        with open(meta, "r") as f:
            meta_txt = f.read()
            meta_json = make_json(meta_txt)
        path_json = ".".join(zarr_config.out.split(".")[:-2]) + ".json"
        with open(path_json, "w") as f:
            json.dump(meta_json, f, indent=4)
        vx = meta_json["PixelSize"]
        unit = meta_json["PixelSizeUnits"]
    else:
        vx = [1, 1, 1]
        unit = "um"

    # Prepare Zarr group
    omz = open_zarr_group(zarr_config)

    if not hasattr(inp, "dtype"):
        raise Exception("Input is not a numpy array. This is unexpected.")
    if len(inp.shape) != 3:
        raise Exception("Input array is not 3d:", inp.shape)

    inp_chunk = [min(x, zarr_config.max_load) for x in inp.shape]
    nk = ceildiv(inp.shape[0], inp_chunk[0])
    nj = ceildiv(inp.shape[1], inp_chunk[1])
    ni = ceildiv(inp.shape[2], inp_chunk[2])

    dataset = create_array(omz, "0", shape=inp.shape, zarr_config=zarr_config,
                           dtype=np.dtype(inp.dtype))

    for idx, slc in chunk_slice_generator(inp.shape, inp_chunk):
        logger.info(
            f"Processing chunk {idx} of "  # [{nx:03d}, {ny:03d}, {nz:03d}]
        )
        loaded_chunk = inp[slc]
        dataset[slc] = loaded_chunk

    generate_pyramid(omz, mode="mean", no_pyramid_axis=zarr_config.no_pyramid_axis)
    logger.info("Write OME-Zarr multiscale metadata")
    write_ome_metadata(omz, axes=["z", "y", "x"], space_unit=to_ome_unit(unit))

    if not zarr_config.nii:
        logger.info("Conversion complete.")
        return

    # Write NIfTI-Zarr header
    arr = omz["0"]
    header, _ = default_nifti_header(arr,
                                     omz.attrs.get("ome", omz.attrs).get("multiscales"))
    reversed_shape = list(reversed(arr.shape))
    affine = orientation_to_affine(orientation, *vx[::-1])
    if center:
        affine = center_affine(affine, reversed_shape[:3])
    header.set_data_shape(reversed_shape)
    header.set_data_dtype(arr.dtype)
    header.set_qform(affine)
    header.set_sform(affine)
    header.set_xyzt_units(to_nifti_unit(unit))

    write_nifti_header(omz, header)
