{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"linc-convert: Data conversion tools for the LINC project","text":"<p>The <code>linc-convert</code> package converts dark-field microscopy, light-sheet microscopy, and polarization-sensitive optical coherence tomography (PS-OCT) files to the OME-Zarr file format.</p> <p></p>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>Getting Started</li> <li>LINC data conversion code on GitHub</li> <li>LINC Homepage</li> </ul>"},{"location":"#support","title":"Support","text":"<p>For questions, bug reports, and feature requests, please file an issue on the linc-convert repository.</p>"},{"location":"about/","title":"About this doc","text":""},{"location":"about/#acknowledgements","title":"Acknowledgements","text":"<p>Thank you to the DANDI Archive project for setting up the documentation framework that is utilized here.  See the DANDI Docs for more information.</p>"},{"location":"about/#license","title":"License","text":"<p>This work is licensed under a Creative Commons Attribution 4.0 International License.</p>"},{"location":"api/","title":"Api","text":"<ul> <li>Welcome</li> <li>Contribute</li> <li>About</li> <li>API<ul> <li>cli</li> <li>modalities<ul> <li>df<ul> <li>cli</li> <li>multi_slice</li> <li>single_slice</li> </ul> </li> <li>lsm<ul> <li>cli</li> <li>mosaic</li> </ul> </li> <li>psoct<ul> <li>_utils</li> <li>cli</li> <li>multi_slice</li> <li>single_volume</li> </ul> </li> <li>wk<ul> <li>cli</li> <li>webknossos_annotation</li> </ul> </li> </ul> </li> <li>utils<ul> <li>j2k</li> <li>math</li> <li>orientation</li> <li>unit</li> <li>zarr</li> </ul> </li> </ul> </li> </ul>"},{"location":"contribute/","title":"Contribute to this documentation","text":"<p>If you find an issue with this documentation please file an issue or submit a pull request on the linc-convert repository.</p> <p>If you would like to contribute to the LINC documentation and render the documentation locally as you make edits, please follow the steps below:</p> <ol> <li>Fork the linc-convert repository and clone it to your computer.</li> <li>Set up a Python environment with the dependencies in the requirements.txt file.</li> <li>Within the Python environment, run <code>mkdocs serve</code>.  This will build the website and start a local webserver (e.g. at http://127.0.0.1:8000) with your documentation.</li> <li>As you continue to edit the markdown files or configuration file, your documentation will be automatically re-built and rendered locally.</li> <li>Commit your changes and submit a pull request.</li> </ol>"},{"location":"installation/","title":"Installation","text":"<ol> <li>(Optional) Create a new environment    <pre><code>conda create -n linc-convert python=3.11\n</code></pre></li> <li>(Optional) Activate the environment    <pre><code>conda activate linc-convert\n</code></pre></li> <li>Install the <code>linc-convert</code> package in your environment    <pre><code>pip install \"linc-convert[all] @ git+https://github.com/lincbrain/linc-convert.git@main\"\n</code></pre> If you don't want to install all dependencies, you can install the dependencies for your specific use case. Replace <code>all</code> in the above command with:<ul> <li><code>df</code> for dark-field microscopy</li> <li><code>lsm</code> for light-sheet microscopy</li> <li><code>psoct</code> for polarization-sensitive optical coherence tomography</li> <li><code>wk</code> for Webknossos annotations</li> <li><code>ts</code> for the TensorStore backend</li> </ul> </li> <li>Run the command-line interface to ensure that installation was successful    <pre><code>linc-convert --help\n</code></pre></li> <li>View the list of arguments for a modality by running, for example:    <pre><code>linc-convert psoct --help\n</code></pre></li> <li>View the full list of parameters by running, for example:    <pre><code>linc-convert psoct single-volume --help\n</code></pre></li> </ol>"},{"location":"api/cli/","title":"Cli","text":""},{"location":"api/cli/#linc_convert.cli","title":"linc_convert.cli","text":"<p>Root command line entry point.</p>"},{"location":"api/modalities/__init__/","title":"init","text":""},{"location":"api/modalities/__init__/#linc_convert.modalities","title":"linc_convert.modalities","text":"<p>Converters for all imaging modalities.</p>"},{"location":"api/modalities/df/__init__/","title":"init","text":""},{"location":"api/modalities/df/__init__/#linc_convert.modalities.df","title":"linc_convert.modalities.df","text":"<p>Dark Field microscopy converters.</p>"},{"location":"api/modalities/df/cli/","title":"Cli","text":""},{"location":"api/modalities/df/cli/#linc_convert.modalities.df.cli","title":"linc_convert.modalities.df.cli","text":"<p>Entry-points for Dark Field microscopy converter.</p>"},{"location":"api/modalities/df/multi_slice/","title":"Multi slice","text":""},{"location":"api/modalities/df/multi_slice/#linc_convert.modalities.df.multi_slice","title":"linc_convert.modalities.df.multi_slice","text":"<p>Convert JPEG2000 files generated by MBF-Neurolucida into a OME-ZARR pyramid.</p> <p>We do not recompute the image pyramid but instead reuse the JPEG2000 levels (obtained by wavelet transform).</p>"},{"location":"api/modalities/df/multi_slice/#linc_convert.modalities.df.multi_slice.convert","title":"convert","text":"<pre><code>convert(inp, *, zarr_config=None, orientation='coronal', center=True, thickness=None, **kwargs)\n</code></pre> <p>Convert JPEG2000 files generated by MBF-Neurolucida into a Zarr pyramid.</p> <p>It does not recompute the image pyramid but instead reuse the JPEG2000 levels (obtained by wavelet transform).</p> <p>This command converts a batch of slices and stacks them together into a single 3D Zarr.</p> Orientation <p>The anatomical orientation of the slice is given in terms of RAS axes.</p> <p>It is a combination of two letters from the set <code>{\"L\", \"R\", \"A\", \"P\", \"I\", \"S\"}</code>, where</p> <ul> <li>the first letter corresponds to the horizontal dimension and   indicates the anatomical meaning of the right of the jp2 image,</li> <li>the second letter corresponds to the vertical dimension and   indicates the anatomical meaning of the bottom of the jp2 image,</li> <li>the third letter corresponds to the slice dimension and   indicates the anatomical meaning of the end of the stack.</li> </ul> <p>We also provide the aliases</p> <ul> <li><code>\"coronal\"</code> == <code>\"LI\"</code></li> <li><code>\"axial\"</code> == <code>\"LP\"</code></li> <li><code>\"sagittal\"</code> == <code>\"PI\"</code></li> </ul> <p>The orientation flag is only useful when converting to nifti-zarr.</p> <p>Parameters:</p> Name Type Description Default <code>inp</code> <code>list[str]</code> <p>Path to the input slices</p> required <code>orientation</code> <code>str</code> <p>Orientation of the slice</p> <code>'coronal'</code> <code>center</code> <code>bool</code> <p>Set RAS[0, 0, 0] at FOV center</p> <code>True</code> <code>thickness</code> <code>float | None</code> <p>Slice thickness</p> <code>None</code>"},{"location":"api/modalities/df/single_slice/","title":"Single slice","text":""},{"location":"api/modalities/df/single_slice/#linc_convert.modalities.df.single_slice","title":"linc_convert.modalities.df.single_slice","text":"<p>Converts JPEG2000 files generated by MBF-Neurolucida into a OME-ZARR pyramid.</p> <p>It does not recompute the image pyramid but instead reuse the JPEG2000 levels (obtained by wavelet transform).</p>"},{"location":"api/modalities/df/single_slice/#linc_convert.modalities.df.single_slice.convert","title":"convert","text":"<pre><code>convert(inp, *, zarr_config=None, max_load=16384, orientation='coronal', center=True, thickness=None, **kwargs)\n</code></pre> <p>Convert a JPEG2000 file generated by MBF-Neurolucida into a Zarr pyramid.</p> <p>It does not recompute the image pyramid but instead reuse the JPEG2000 levels (obtained by wavelet transform).</p> Orientation <p>The anatomical orientation of the slice is given in terms of RAS axes.</p> <p>It is a combination of two letters from the set <code>{\"L\", \"R\", \"A\", \"P\", \"I\", \"S\"}</code>, where</p> <ul> <li>the first letter corresponds to the horizontal dimension and     indicates the anatomical meaning of the right of the jp2 image,</li> <li>the second letter corresponds to the vertical dimension and     indicates the anatomical meaning of the bottom of the jp2 image.</li> </ul> <p>We also provide the aliases</p> <ul> <li><code>\"coronal\"</code> == <code>\"LI\"</code></li> <li><code>\"axial\"</code> == <code>\"LP\"</code></li> <li><code>\"sagittal\"</code> == <code>\"PI\"</code></li> </ul> <p>The orientation flag is only useful when converting to nifti-zarr.</p> <p>Parameters:</p> Name Type Description Default <code>inp</code> <code>str</code> <p>Path to the input JP2 file</p> required <code>out</code> <p>Path to the output Zarr directory [.ome.zarr] required <code>max_load</code> <code>int</code> <p>Maximum input chunk size</p> <code>16384</code> <code>orientation</code> <code>str</code> <p>Orientation of the slice</p> <code>'coronal'</code> <code>center</code> <code>bool</code> <p>Set RAS[0, 0, 0] at FOV center</p> <code>True</code> <code>thickness</code> <code>float | None</code> <p>Slice thickness</p> <code>None</code>"},{"location":"api/modalities/lsm/__init__/","title":"init","text":""},{"location":"api/modalities/lsm/__init__/#linc_convert.modalities.lsm","title":"linc_convert.modalities.lsm","text":"<p>Light Sheet Microscopy converters.</p>"},{"location":"api/modalities/lsm/cli/","title":"Cli","text":""},{"location":"api/modalities/lsm/cli/#linc_convert.modalities.lsm.cli","title":"linc_convert.modalities.lsm.cli","text":"<p>Entry-points for light sheet microscopy converter.</p>"},{"location":"api/modalities/lsm/mosaic/","title":"Mosaic","text":""},{"location":"api/modalities/lsm/mosaic/#linc_convert.modalities.lsm.mosaic","title":"linc_convert.modalities.lsm.mosaic","text":"<p>Convert a collection of tiff files generated by the LSM pipeline into a Zarr.</p> <p>Example input files can be found at https://lincbrain.org/dandiset/000004/0.240319.1924/files?location=derivatives%2F</p>"},{"location":"api/modalities/lsm/mosaic/#linc_convert.modalities.lsm.mosaic.convert","title":"convert","text":"<pre><code>convert(inp, *, zarr_config=None, max_load=512, orientation='coronal', center=True, thickness=None, voxel_size=(1, 1, 1), **kwargs)\n</code></pre> <p>Convert a collection of tiff files generated by the LSM pipeline into ZARR.</p> Orientation <p>The anatomical orientation of the slice is given in terms of RAS axes.</p> <p>It is a combination of two letters from the set <code>{\"L\", \"R\", \"A\", \"P\", \"I\", \"S\"}</code>, where</p> <ul> <li>the first letter corresponds to the horizontal dimension and     indicates the anatomical meaning of the right of the jp2 image,</li> <li>the second letter corresponds to the vertical dimension and     indicates the anatomical meaning of the bottom of the jp2 image.</li> </ul> <p>We also provide the aliases</p> <ul> <li><code>\"coronal\"</code> == <code>\"LI\"</code></li> <li><code>\"axial\"</code> == <code>\"LP\"</code></li> <li><code>\"sagittal\"</code> == <code>\"PI\"</code></li> </ul> <p>The orientation flag is only useful when converting to nifti-zarr.</p> <p>Parameters:</p> Name Type Description Default <code>inp</code> <code>str</code> <p>Path to the root directory, which contains a collection of subfolders named <code>*_z{:02d}_y{:02d}*</code>, each containing a collection of files named <code>*_plane{:03d}_c{:d}.tiff</code>.</p> required <code>out</code> <p>Path to the output Zarr directory [.ome.zarr] required <code>max_load</code> <code>int</code> <p>Maximum input chunk size when building pyramid</p> <code>512</code> <code>orientation</code> <code>str</code> <p>Orientation of the slice</p> <code>'coronal'</code> <code>center</code> <code>bool</code> <p>Set RAS[0, 0, 0] at FOV center</p> <code>True</code> <code>voxel_size</code> <code>list[float]</code> <p>Voxel size along the X, Y and Z dimension, in micron.</p> <code>(1, 1, 1)</code>"},{"location":"api/modalities/psoct/__init__/","title":"init","text":""},{"location":"api/modalities/psoct/__init__/#linc_convert.modalities.psoct","title":"linc_convert.modalities.psoct","text":"<p>Polarization-sensitive optical coherence tomography converters.</p>"},{"location":"api/modalities/psoct/_utils/","title":"utils","text":""},{"location":"api/modalities/psoct/_utils/#linc_convert.modalities.psoct._utils","title":"linc_convert.modalities.psoct._utils","text":""},{"location":"api/modalities/psoct/_utils/#linc_convert.modalities.psoct._utils.make_json","title":"make_json","text":"<pre><code>make_json(oct_meta)\n</code></pre> <p>Make json from OCT metadata.</p> Expected input: <p>Image medium: 60% TDE Center Wavelength: 1294.84nm Axial resolution: 4.9um Lateral resolution: 4.92um FOV: 3x3mm Voxel size: 3x3x3um Depth focus range: 225um Number of focuses: 2 Focus #: 2 Slice thickness: 450um. Number of slices: 75 Slice #:23 Modality: dBI</p>"},{"location":"api/modalities/psoct/_utils/#linc_convert.modalities.psoct._utils.struct_arr_to_dict","title":"struct_arr_to_dict","text":"<pre><code>struct_arr_to_dict(arr)\n</code></pre> <p>Convert a NumPy structured array (single record) to a dictionary.</p> <p>Returns:</p> Type Description <code>    dict: Dictionary mapping field names to their values.</code>"},{"location":"api/modalities/psoct/_utils/#linc_convert.modalities.psoct._utils.find_experiment_params","title":"find_experiment_params","text":"<pre><code>find_experiment_params(exp_file)\n</code></pre> <p>Load experiment parameters from a .mat file, detecting if it's a Fiji experiment.</p> <p>Returns:</p> Type Description <code>    tuple:</code> <ul> <li>dict: Experiment parameters.</li> <li>bool: True if it's a Fiji experiment, False otherwise.</li> </ul> <p>Raises:</p> Type Description <code>    ValueError: If no experiment key is found in the file.</code>"},{"location":"api/modalities/psoct/_utils/#linc_convert.modalities.psoct._utils.mat_vars","title":"mat_vars","text":"<pre><code>mat_vars(mat_file)\n</code></pre> <p>Yield variable names from a .mat file, excluding internal variables.</p> <p>Yields:</p> Type Description <code>    str: Variable names not starting with '__'.</code>"},{"location":"api/modalities/psoct/_utils/#linc_convert.modalities.psoct._utils.atleast_2d_trailing","title":"atleast_2d_trailing","text":"<pre><code>atleast_2d_trailing(arr)\n</code></pre> <p>Ensure the input is at least 2D by adding a new axis at the end if needed.</p> <p>If the input is 1D, it becomes shape (N, 1). If the input is 0D (scalar), it becomes shape (1, 1). If it's already 2D or more, it's returned unchanged.</p> <p>Returns:</p> Type Description <code>    np.ndarray: A 2D or higher NumPy array with at least two dimensions.</code>"},{"location":"api/modalities/psoct/cli/","title":"Cli","text":""},{"location":"api/modalities/psoct/cli/#linc_convert.modalities.psoct.cli","title":"linc_convert.modalities.psoct.cli","text":"<p>Entry-points for polarization-sensitive optical coherence tomography converter.</p>"},{"location":"api/modalities/psoct/multi_slice/","title":"Multi slice","text":""},{"location":"api/modalities/psoct/multi_slice/#linc_convert.modalities.psoct.multi_slice","title":"linc_convert.modalities.psoct.multi_slice","text":"<p>Matlab to OME-Zarr.</p> <p>Converts Matlab files generated by the MGH in-house OCT pipeline into a OME-ZARR pyramid.</p>"},{"location":"api/modalities/psoct/multi_slice/#linc_convert.modalities.psoct.multi_slice.convert","title":"convert","text":"<pre><code>convert(inp, *, key=None, meta=None, orientation='RAS', center=True, dtype=None, zarr_config=None, **kwargs)\n</code></pre> <p>Matlab to OME-Zarr.</p> <p>Convert OCT volumes in raw matlab files into a pyramidal OME-ZARR (or NIfTI-Zarr) hierarchy.</p> <p>This command assumes that each slice in a volume is stored in a different mat file. All slices must have the same shape and will be concatenated into a 3D Zarr.</p> <p>Parameters:</p> Name Type Description Default <code>inp</code> <code>list of str</code> <p>Paths to the input mat files.</p> required <code>key</code> <code>Optional[str]</code> <p>Key of the array to be extracted; defaults to the first key found.</p> <code>None</code> <code>meta</code> <code>str</code> <p>Path to the metadata file.</p> <code>None</code> <code>orientation</code> <code>str</code> <p>Orientation of the volume.</p> <code>'RAS'</code> <code>center</code> <code>bool</code> <p>Set RAS[0, 0, 0] at FOV center.</p> <code>True</code> <code>dtype</code> <code>Optional[str]</code> <p>Data type to write into.</p> <code>None</code>"},{"location":"api/modalities/psoct/single_volume/","title":"Single volume","text":""},{"location":"api/modalities/psoct/single_volume/#linc_convert.modalities.psoct.single_volume","title":"linc_convert.modalities.psoct.single_volume","text":"<p>Matlab to OME-Zarr.</p> <p>Converts Matlab files generated by the MGH in-house OCT pipeline into a OME-ZARR pyramid.</p>"},{"location":"api/modalities/psoct/single_volume/#linc_convert.modalities.psoct.single_volume.convert","title":"convert","text":"<pre><code>convert(inp, *, key=None, meta=None, orientation='RAS', center=True, zarr_config=None, **kwargs)\n</code></pre> <p>Matlab to OME-Zarr.</p> <p>Convert OCT volumes in raw matlab files into a pyramidal OME-ZARR (or NIfTI-Zarr) hierarchy.</p> <p>Parameters:</p> Name Type Description Default <code>inp</code> <code>str</code> <p>Path to the input mat file</p> required <code>key</code> <code>Optional[str]</code> <p>Key of the array to be extracted, default to first key found</p> <code>None</code> <code>meta</code> <code>str</code> <p>Path to the metadata file</p> <code>None</code> <code>chunk</code> <p>Output chunk size</p> required <code>compressor</code> <code>(blosc, zlib, raw)</code> <p>Compression method</p> <code>blosc</code> <code>compressor_opt</code> <p>Compression options</p> required <code>max_load</code> <p>Maximum input chunk size</p> required <code>max_levels</code> <p>Maximum number of pyramid levels</p> required <code>no_pool</code> <p>Index of dimension to not pool when building pyramid</p> required <code>nii</code> <p>Convert to nifti-zarr. True if path ends in \".nii.zarr\"</p> required <code>orientation</code> <code>str</code> <p>Orientation of the volume</p> <code>'RAS'</code> <code>center</code> <code>bool</code> <p>Set RAS[0, 0, 0] at FOV center</p> <code>True</code>"},{"location":"api/modalities/wk/__init__/","title":"init","text":""},{"location":"api/modalities/wk/__init__/#linc_convert.modalities.wk","title":"linc_convert.modalities.wk","text":"<p>Webknossos annotation converters.</p>"},{"location":"api/modalities/wk/cli/","title":"Cli","text":""},{"location":"api/modalities/wk/cli/#linc_convert.modalities.wk.cli","title":"linc_convert.modalities.wk.cli","text":"<p>Entry-points for Webknossos annotation converter.</p>"},{"location":"api/modalities/wk/webknossos_annotation/","title":"Webknossos annotation","text":""},{"location":"api/modalities/wk/webknossos_annotation/#linc_convert.modalities.wk.webknossos_annotation","title":"linc_convert.modalities.wk.webknossos_annotation","text":"<p>Convert annotation downloaded from webknossos into ome.zarr format.</p>"},{"location":"api/modalities/wk/webknossos_annotation/#linc_convert.modalities.wk.webknossos_annotation.convert","title":"convert","text":"<pre><code>convert(wkw_dir=None, ome_dir=None, dic=None, *, zarr_config=None, **kwargs)\n</code></pre> <p>Convert annotations (in .wkw format) from webknossos to ome.zarr format.</p> <p>This script converts annotations from webknossos, following the czyx direction, to the ome.zarr format. The conversion ensures that the annotations match the underlying dataset.</p> <p>Parameters:</p> Name Type Description Default <code>wkw_dir</code> <code>str</code> <p>Path to the unzipped manual annotation folder downloaded from webknossos in .wkw format. For example: .../annotation_folder/data_Volume.</p> <code>None</code> <code>ome_dir</code> <code>str</code> <p>Path to the underlying ome.zarr dataset, following the BIDS naming standard.</p> <code>None</code> <code>out</code> <code>str</code> <p>Path to the output directory for saving the converted ome.zarr. The ome.zarr file name is generated automatically based on ome_dir and the initials of the annotator.</p> required <code>dic</code> <code>dict</code> <p>A dictionary mapping annotation values to the following standard values if annotation doesn't match the standard. The dictionary should be in single quotes, with keys in double quotes, for example: dic = '{\"2\": 1, \"4\": 2}'. The standard values are: - 0: background - 1: Light Bundle - 2: Moderate Bundle - 3: Dense Bundle - 4: Light Terminal - 5: Moderate Terminal - 6: Dense Terminal - 7: Single Fiber</p> <code>None</code>"},{"location":"api/modalities/wk/webknossos_annotation/#linc_convert.modalities.wk.webknossos_annotation.get_mask_name","title":"get_mask_name","text":"<pre><code>get_mask_name(level)\n</code></pre> <p>Return the name of the mask for a given resolution level.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>int</code> <p>The resolution level for which to return the mask name.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The name of the mask for the given level.</p>"},{"location":"api/modalities/wk/webknossos_annotation/#linc_convert.modalities.wk.webknossos_annotation.cal_distance","title":"cal_distance","text":"<pre><code>cal_distance(img)\n</code></pre> <p>Return the distance of non-zero values to the top border.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>ndarray</code> <p>The array to calculate distance of object inside to border</p> required <p>Returns:</p> Type Description <code>int</code> <p>The distance of non-zero to the top border</p>"},{"location":"api/modalities/wk/webknossos_annotation/#linc_convert.modalities.wk.webknossos_annotation.find_borders","title":"find_borders","text":"<pre><code>find_borders(img)\n</code></pre> <p>Return the distances of non-zero values to four borders.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>ndarray</code> <p>The array to calculate distance of object inside to border</p> required <p>Returns:</p> Type Description <code>int</code> <p>The distance of non-zero values to four borders</p>"},{"location":"api/utils/__init__/","title":"init","text":""},{"location":"api/utils/__init__/#linc_convert.utils","title":"linc_convert.utils","text":"<p>Various utilities.</p>"},{"location":"api/utils/j2k/","title":"J2k","text":""},{"location":"api/utils/j2k/#linc_convert.utils.io.j2k","title":"linc_convert.utils.io.j2k","text":"<p>Utilities for JPEG2000 files.</p>"},{"location":"api/utils/j2k/#linc_convert.utils.io.j2k.WrappedJ2K","title":"WrappedJ2K  <code>dataclass</code>","text":"<pre><code>WrappedJ2K(j2k, level=0, channel_first=True)\n</code></pre> <p>Array-like wrapper around a JPEG2000 object.</p> <p>A wrapper around the J2K object at any resolution level, and with virtual transposition of the axes into [C, H, W] order.</p> <p>The resulting object can be sliced, but each index must be a <code>slice</code> (dropping axes using integer indices or adding axes using <code>None</code> indices is forbidden).</p> <p>The point is to ensure that the zarr writer only loads chunk-sized data.</p> <p>Parameters:</p> Name Type Description Default <code>j2k</code> <code>Jp2k</code> <p>The JPEG2000 object.</p> required <code>level</code> <code>int</code> <p>Resolution level to map (highest resolution = 0).</p> <code>0</code> <code>channel_first</code> <code>bool</code> <p>Return an array with shape (C, H, W) instead of (H, W, C) when there is a channel dimension.</p> <code>True</code>"},{"location":"api/utils/j2k/#linc_convert.utils.io.j2k.WrappedJ2K.shape","title":"shape  <code>property</code>","text":"<pre><code>shape\n</code></pre> <p>Shape of the current level.</p>"},{"location":"api/utils/j2k/#linc_convert.utils.io.j2k.WrappedJ2K.dtype","title":"dtype  <code>property</code>","text":"<pre><code>dtype\n</code></pre> <p>Data type of the wrapped image.</p>"},{"location":"api/utils/j2k/#linc_convert.utils.io.j2k.WrappedJ2K.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(index)\n</code></pre> <p>Multidimensional slicing of the wrapped array.</p>"},{"location":"api/utils/j2k/#linc_convert.utils.io.j2k.get_pixelsize","title":"get_pixelsize","text":"<pre><code>get_pixelsize(j2k)\n</code></pre> <p>Read pixelsize from the JPEG2000 file.</p>"},{"location":"api/utils/math/","title":"Math","text":""},{"location":"api/utils/math/#linc_convert.utils.math","title":"linc_convert.utils.math","text":"<p>Math utilities.</p>"},{"location":"api/utils/math/#linc_convert.utils.math.ceildiv","title":"ceildiv","text":"<pre><code>ceildiv(x, y)\n</code></pre> <p>Ceil of ratio of two numbers.</p>"},{"location":"api/utils/math/#linc_convert.utils.math.floordiv","title":"floordiv","text":"<pre><code>floordiv(x, y)\n</code></pre> <p>Floor of ratio of two numbers.</p>"},{"location":"api/utils/orientation/","title":"Orientation","text":""},{"location":"api/utils/orientation/#linc_convert.utils.orientation","title":"linc_convert.utils.orientation","text":"<p>Orientation of an array of voxels with respect to world space.</p>"},{"location":"api/utils/orientation/#linc_convert.utils.orientation.orientation_ensure_3d","title":"orientation_ensure_3d","text":"<pre><code>orientation_ensure_3d(orientation)\n</code></pre> <p>Convert an ND orientation string to a 3D orientation string.</p> <p>Parameters:</p> Name Type Description Default <code>orientation</code> <code>str</code> <p>A 2D or 3D orientation string, such as <code>\"RA\"</code> or <code>\"RAS\"</code>.</p> required <p>Returns:</p> Name Type Description <code>orientation</code> <code>str</code> <p>A 3D orientation string compatible with the input orientaition</p>"},{"location":"api/utils/orientation/#linc_convert.utils.orientation.orientation_to_affine","title":"orientation_to_affine","text":"<pre><code>orientation_to_affine(orientation, vxw=1, vxh=1, vxd=1)\n</code></pre> <p>Build an affine matrix from an orientation string and voxel size.</p> <p>Parameters:</p> Name Type Description Default <code>orientation</code> <code>str</code> <p>Orientation string</p> required <code>vxw</code> <code>float</code> <p>Width voxel size</p> <code>1</code> <code>vxh</code> <code>float</code> <p>Height voxel size</p> <code>1</code> <code>vxd</code> <code>float</code> <p>Depth voxel size</p> <code>1</code> <p>Returns:</p> Name Type Description <code>affine</code> <code>(4, 4) array</code> <p>Affine orientation matrix</p>"},{"location":"api/utils/orientation/#linc_convert.utils.orientation.center_affine","title":"center_affine","text":"<pre><code>center_affine(affine, shape)\n</code></pre> <p>Ensure that the center of the field-of-view has world coordinate (0,0,0).</p> <p>The input affine is NOT modified in-place</p> <p>Parameters:</p> Name Type Description Default <code>affine</code> <code>array</code> <p>Orientation affine matrix</p> required <code>shape</code> <code>list[int]</code> <p>Shape of the array of voxels</p> required <p>Returns:</p> Name Type Description <code>affine</code> <code>array</code> <p>Modified affine matrix.</p>"},{"location":"api/utils/unit/","title":"Unit","text":""},{"location":"api/utils/unit/#linc_convert.utils.unit","title":"linc_convert.utils.unit","text":"<p>Converts units between zarr and other specifications.</p>"},{"location":"api/utils/unit/#linc_convert.utils.unit.convert_unit","title":"convert_unit","text":"<pre><code>convert_unit(value, src, dst)\n</code></pre> <p>Convert unit for a value.</p>"},{"location":"api/utils/unit/#linc_convert.utils.unit.to_ome_unit","title":"to_ome_unit","text":"<pre><code>to_ome_unit(unit)\n</code></pre> <p>Convert unit to ome-zarr spec.</p>"},{"location":"api/utils/unit/#linc_convert.utils.unit.to_nifti_unit","title":"to_nifti_unit","text":"<pre><code>to_nifti_unit(unit)\n</code></pre> <p>Convert unit to nifti spec.</p>"},{"location":"api/utils/unit/#linc_convert.utils.unit.unit_to_scale","title":"unit_to_scale","text":"<pre><code>unit_to_scale(unit)\n</code></pre> <p>Convert unit to scale.</p>"},{"location":"api/utils/zarr/","title":"Zarr","text":""},{"location":"api/utils/zarr/#linc_convert.utils.io.zarr","title":"linc_convert.utils.io.zarr","text":"<p>ZarrIO module for handling Zarr data structures.</p>"},{"location":"api/utils/zarr/#linc_convert.utils.io.zarr.ZarrPythonArray","title":"ZarrPythonArray","text":"<pre><code>ZarrPythonArray(array)\n</code></pre> <p>               Bases: <code>ZarrArray</code></p> <p>Zarr Array implementation using the zarr-python library.</p> <p>Initialize the ZarrPythonArray with a zarr.Array.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>Array</code> <p>Underlying Zarr array.</p> required"},{"location":"api/utils/zarr/#linc_convert.utils.io.zarr.ZarrPythonArray.ndim","title":"ndim  <code>property</code>","text":"<pre><code>ndim\n</code></pre> <p>Number of dimensions of the array.</p>"},{"location":"api/utils/zarr/#linc_convert.utils.io.zarr.ZarrPythonArray.shape","title":"shape  <code>property</code>","text":"<pre><code>shape\n</code></pre> <p>Shape of the array.</p>"},{"location":"api/utils/zarr/#linc_convert.utils.io.zarr.ZarrPythonArray.dtype","title":"dtype  <code>property</code>","text":"<pre><code>dtype\n</code></pre> <p>Data type of the array.</p>"},{"location":"api/utils/zarr/#linc_convert.utils.io.zarr.ZarrPythonArray.chunks","title":"chunks  <code>property</code>","text":"<pre><code>chunks\n</code></pre> <p>Chunk shape for the array.</p>"},{"location":"api/utils/zarr/#linc_convert.utils.io.zarr.ZarrPythonArray.shards","title":"shards  <code>property</code>","text":"<pre><code>shards\n</code></pre> <p>Shard shape, if supported; otherwise None.</p>"},{"location":"api/utils/zarr/#linc_convert.utils.io.zarr.ZarrPythonArray.attrs","title":"attrs  <code>property</code>","text":"<pre><code>attrs\n</code></pre> <p>Access metadata/attributes for this node.</p>"},{"location":"api/utils/zarr/#linc_convert.utils.io.zarr.ZarrPythonArray.zarr_version","title":"zarr_version  <code>property</code>","text":"<pre><code>zarr_version\n</code></pre> <p>Get the Zarr format version.</p>"},{"location":"api/utils/zarr/#linc_convert.utils.io.zarr.ZarrPythonArray.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key)\n</code></pre> <p>Read data from the array.</p>"},{"location":"api/utils/zarr/#linc_convert.utils.io.zarr.ZarrPythonArray.__setitem__","title":"__setitem__","text":"<pre><code>__setitem__(key, value)\n</code></pre> <p>Write data to the array.</p>"},{"location":"api/utils/zarr/#linc_convert.utils.io.zarr.ZarrPythonArray.__getattr__","title":"__getattr__","text":"<pre><code>__getattr__(name)\n</code></pre> <p>Delegate any unknown attributes to the underlying array.</p>"},{"location":"api/utils/zarr/#linc_convert.utils.io.zarr.ZarrPythonGroup","title":"ZarrPythonGroup","text":"<pre><code>ZarrPythonGroup(zarr_group)\n</code></pre> <p>               Bases: <code>ZarrGroup</code></p> <p>Zarr Group implementation using the zarr-python library.</p> <p>Initialize the ZarrPythonGroup with a zarr.Group.</p> <p>Parameters:</p> Name Type Description Default <code>zarr_group</code> <code>Group</code> <p>Underlying Zarr Python group.</p> required"},{"location":"api/utils/zarr/#linc_convert.utils.io.zarr.ZarrPythonGroup.attrs","title":"attrs  <code>property</code>","text":"<pre><code>attrs\n</code></pre> <p>Access metadata/attributes for this node.</p>"},{"location":"api/utils/zarr/#linc_convert.utils.io.zarr.ZarrPythonGroup.zarr_version","title":"zarr_version  <code>property</code>","text":"<pre><code>zarr_version\n</code></pre> <p>Get the Zarr format version.</p>"},{"location":"api/utils/zarr/#linc_convert.utils.io.zarr.ZarrPythonGroup.from_config","title":"from_config  <code>classmethod</code>","text":"<pre><code>from_config(zarr_config)\n</code></pre> <p>Create a Zarr group from a configuration object.</p>"},{"location":"api/utils/zarr/#linc_convert.utils.io.zarr.ZarrPythonGroup.keys","title":"keys","text":"<pre><code>keys()\n</code></pre> <p>Get the names of all subgroups and arrays in this group.</p>"},{"location":"api/utils/zarr/#linc_convert.utils.io.zarr.ZarrPythonGroup.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key)\n</code></pre> <p>Get a subgroup or array by name within this group.</p>"},{"location":"api/utils/zarr/#linc_convert.utils.io.zarr.ZarrPythonGroup.__setitem__","title":"__setitem__","text":"<pre><code>__setitem__(key, value)\n</code></pre> <p>Set a subgroup or array by name within this group.</p>"},{"location":"api/utils/zarr/#linc_convert.utils.io.zarr.ZarrPythonGroup.__delitem__","title":"__delitem__","text":"<pre><code>__delitem__(key)\n</code></pre> <p>Delete a subgroup or array by name within this group.</p>"},{"location":"api/utils/zarr/#linc_convert.utils.io.zarr.ZarrPythonGroup.__iter__","title":"__iter__","text":"<pre><code>__iter__()\n</code></pre> <p>Iterate over the names of all subgroups and arrays in this group.</p>"},{"location":"api/utils/zarr/#linc_convert.utils.io.zarr.ZarrPythonGroup.__getattr__","title":"__getattr__","text":"<pre><code>__getattr__(name)\n</code></pre> <p>Delegate attribute access to the underlying Zarr group.</p>"},{"location":"api/utils/zarr/#linc_convert.utils.io.zarr.ZarrPythonGroup.create_group","title":"create_group","text":"<pre><code>create_group(name, overwrite=False)\n</code></pre> <p>Create or open a subgroup within this group.</p>"},{"location":"api/utils/zarr/#linc_convert.utils.io.zarr.ZarrPythonGroup.create_array","title":"create_array","text":"<pre><code>create_array(name, shape, dtype, *, zarr_config=None, data=None, **kwargs)\n</code></pre> <p>Create a new array within this group.</p>"},{"location":"api/utils/zarr/#linc_convert.utils.io.zarr.ZarrPythonGroup.create_array_from_base","title":"create_array_from_base","text":"<pre><code>create_array_from_base(name, shape, data=None, **kwargs)\n</code></pre> <p>Create a new array using the properties from a base_level object.</p>"},{"location":"api/utils/zarr/#linc_convert.utils.io.zarr.ZarrTSArray","title":"ZarrTSArray","text":"<pre><code>ZarrTSArray(ts_array)\n</code></pre> <p>               Bases: <code>ZarrArray</code></p> <p>Zarr array backed by TensorStore.</p> <p>Initialize the ZarrTSArray with a TensorStore array.</p> <p>Parameters:</p> Name Type Description Default <code>ts_array</code> <code>TensorStore</code> <p>Underlying TensorStore array.</p> required"},{"location":"api/utils/zarr/#linc_convert.utils.io.zarr.ZarrTSArray.ndim","title":"ndim  <code>property</code>","text":"<pre><code>ndim\n</code></pre> <p>Number of dimensions of the array.</p>"},{"location":"api/utils/zarr/#linc_convert.utils.io.zarr.ZarrTSArray.shape","title":"shape  <code>property</code>","text":"<pre><code>shape\n</code></pre> <p>Shape of the array.</p>"},{"location":"api/utils/zarr/#linc_convert.utils.io.zarr.ZarrTSArray.dtype","title":"dtype  <code>property</code>","text":"<pre><code>dtype\n</code></pre> <p>Data type of the array.</p>"},{"location":"api/utils/zarr/#linc_convert.utils.io.zarr.ZarrTSArray.chunks","title":"chunks  <code>property</code>","text":"<pre><code>chunks\n</code></pre> <p>Chunk shape for the array.</p>"},{"location":"api/utils/zarr/#linc_convert.utils.io.zarr.ZarrTSArray.shards","title":"shards  <code>property</code>","text":"<pre><code>shards\n</code></pre> <p>Shard shape, if supported; otherwise None.</p>"},{"location":"api/utils/zarr/#linc_convert.utils.io.zarr.ZarrTSArray.attrs","title":"attrs  <code>property</code>","text":"<pre><code>attrs\n</code></pre> <p>Access metadata/attributes for this node.</p>"},{"location":"api/utils/zarr/#linc_convert.utils.io.zarr.ZarrTSArray.zarr_version","title":"zarr_version  <code>property</code>","text":"<pre><code>zarr_version\n</code></pre> <p>Get the Zarr format version.</p>"},{"location":"api/utils/zarr/#linc_convert.utils.io.zarr.ZarrTSArray.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key)\n</code></pre> <p>Read data from the array.</p>"},{"location":"api/utils/zarr/#linc_convert.utils.io.zarr.ZarrTSArray.__setitem__","title":"__setitem__","text":"<pre><code>__setitem__(key, value)\n</code></pre> <p>Write data to the array.</p>"},{"location":"api/utils/zarr/#linc_convert.utils.io.zarr.ZarrTSArray.open","title":"open  <code>classmethod</code>","text":"<pre><code>open(path, *, zarr_version=3, create=False, delete_exsisting=False)\n</code></pre> <p>Open an existing Zarr array.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, PathLike]</code> <p>Path to the array\u2019s directory.</p> required <code>zarr_version</code> <code>(2, 3)</code> <p>Zarr format version to use.</p> <code>2</code> <code>mode</code> <code>(r, 'r+', a, w, 'w-')</code> <p>Access mode; see TensorStore docs.</p> <code>'r','r+','a','w','w-'</code> <p>Returns:</p> Type Description <code>ZarrTSArray</code>"},{"location":"api/utils/zarr/#linc_convert.utils.io.zarr.ZarrTSGroup","title":"ZarrTSGroup","text":"<pre><code>ZarrTSGroup(store_path)\n</code></pre> <p>               Bases: <code>ZarrGroup</code></p> <p>Zarr Group implementation using TensorStore as backend.</p> <p>Initialize the ZarrTSGroup.</p> <p>Parameters:</p> Name Type Description Default <code>store_path</code> <code>Union[str, PathLike]</code> <p>Path to the group\u2019s directory.</p> required"},{"location":"api/utils/zarr/#linc_convert.utils.io.zarr.ZarrTSGroup.attrs","title":"attrs  <code>property</code>","text":"<pre><code>attrs\n</code></pre> <p>Access attributes for this node.</p>"},{"location":"api/utils/zarr/#linc_convert.utils.io.zarr.ZarrTSGroup.metadata","title":"metadata  <code>property</code>","text":"<pre><code>metadata\n</code></pre> <p>Access metadata for this node.</p>"},{"location":"api/utils/zarr/#linc_convert.utils.io.zarr.ZarrTSGroup.zarr_version","title":"zarr_version  <code>property</code>","text":"<pre><code>zarr_version\n</code></pre> <p>Get the Zarr format version.</p>"},{"location":"api/utils/zarr/#linc_convert.utils.io.zarr.ZarrTSGroup.from_config","title":"from_config  <code>classmethod</code>","text":"<pre><code>from_config(zarr_config)\n</code></pre> <p>Create a ZarrTSGroup from a configuration object.</p> <p>Parameters:</p> Name Type Description Default <code>zarr_config</code> <code>ZarrConfig</code> <p>Configuration with .out and .zarr_version.</p> required <p>Returns:</p> Type Description <code>ZarrTSGroup</code>"},{"location":"api/utils/zarr/#linc_convert.utils.io.zarr.ZarrTSGroup.open","title":"open  <code>classmethod</code>","text":"<pre><code>open(path, mode='a', *, zarr_version=3)\n</code></pre> <p>Open or create a Zarr group backed by TensorStore.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, PathLike]</code> <p>Path to the Zarr group.</p> required <code>mode</code> <code>(r, 'r+', a, w, 'w-')</code> <p>Persistence mode: 'r' means read only (must exist); 'r+' means read/write (must exist); 'a' means read/write (create if doesn't exist); 'w' means create (overwrite if exists); 'w-' means create (fail if exists).</p> <code>'r','r+','a','w','w-'</code> <code>zarr_version</code> <code>(2, 3)</code> <p>Zarr format version.</p> <code>2,3</code> <p>Returns:</p> Type Description <code>ZarrTSGroup</code>"},{"location":"api/utils/zarr/#linc_convert.utils.io.zarr.ZarrTSGroup.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key)\n</code></pre> <p>Get a subgroup or array by name within this group.</p>"},{"location":"api/utils/zarr/#linc_convert.utils.io.zarr.ZarrTSGroup.__setitem__","title":"__setitem__","text":"<pre><code>__setitem__(key, value)\n</code></pre> <p>Set a subgroup or array by name within this group.</p>"},{"location":"api/utils/zarr/#linc_convert.utils.io.zarr.ZarrTSGroup.__delitem__","title":"__delitem__","text":"<pre><code>__delitem__(key)\n</code></pre> <p>Delete a subgroup or array by name within this group.</p>"},{"location":"api/utils/zarr/#linc_convert.utils.io.zarr.ZarrTSGroup.keys","title":"keys","text":"<pre><code>keys()\n</code></pre> <p>Get the names of all subgroups and arrays in this group.</p>"},{"location":"api/utils/zarr/#linc_convert.utils.io.zarr.ZarrTSGroup.__contains__","title":"__contains__","text":"<pre><code>__contains__(name)\n</code></pre> <p>Check whether a subgroup or array exists in this group.</p>"},{"location":"api/utils/zarr/#linc_convert.utils.io.zarr.ZarrTSGroup.create_group","title":"create_group","text":"<pre><code>create_group(name, overwrite=False)\n</code></pre> <p>Create or open a subgroup within this group.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> required <code>overwrite</code> <code>bool</code> <p>If True, delete existing before creating.</p> <code>False</code> <p>Returns:</p> Type Description <code>ZarrTSGroup</code>"},{"location":"api/utils/zarr/#linc_convert.utils.io.zarr.ZarrTSGroup.create_array","title":"create_array","text":"<pre><code>create_array(name, shape, dtype=np.int32, *, overwrite=True, data=None, zarr_config=None, **kwargs)\n</code></pre> <p>Create a new array within this group.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> required <code>shape</code> <code>Sequence[int]</code> required <code>dtype</code> <code>DTypeLike</code> <code>int32</code> <code>overwrite</code> <code>bool</code> <code>True</code> <code>zarr_config</code> <code>ZarrConfig | None</code> <code>None</code> <code>data</code> <code>ArrayLike | None</code> <code>None</code> <p>Returns:</p> Type Description <code>ZarrTSArray</code>"},{"location":"api/utils/zarr/#linc_convert.utils.io.zarr.ZarrTSGroup.create_array_from_base","title":"create_array_from_base","text":"<pre><code>create_array_from_base(name, shape, data=None, **kwargs)\n</code></pre> <p>Create a new array using metadata of an existing base-level array.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> required <code>shape</code> <code>Sequence[int]</code> required <code>data</code> <code>ArrayLike | None</code> <code>None</code> <p>Returns:</p> Type Description <code>ZarrTSArray</code>"}]}