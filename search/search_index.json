{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"<p>The center for Large-scale Imaging of Neural Circuits (LINC)  (PIs: Haber, Hillman, Yendiki) is funded by the  NIH BRAIN Initiative CONNECTS program. Its goal is to develop novel technologies for imaging brain connections down to  the microscopic scale, and deploy these technologies to image  cortico-subcortical projections that are relevant to deep brain stimulation for  motor and psychiatric disorders.</p>"},{"location":"#about-this-doc","title":"About this doc","text":"<p>The <code>linc-convert</code> package converts dark-field microscopy, light-sheet microscopy, and polarization sensitive optical coherence tomography files to the OME-Zarr file format.</p>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>LINC Homepage</li> <li>LINC data conversion code on GitHub</li> </ul>"},{"location":"#support","title":"Support","text":"<p>For questions, bug reports, and feature requests, please file an issue on the linc-convert repository.</p>"},{"location":"about/","title":"About this doc","text":""},{"location":"about/#acknowledgements","title":"Acknowledgements","text":"<p>Thank you to the DANDI Archive project for setting up the documentation framework that is utilized here.  See the DANDI Handbook for more information.</p>"},{"location":"about/#license","title":"License","text":"<p>This work is licensed under a Creative Commons Attribution 4.0 International License.</p>"},{"location":"api/","title":"Api","text":"<ul> <li>Welcome</li> <li>Contribute</li> <li>About</li> <li>cli</li> <li>modalities<ul> <li>df<ul> <li>cli</li> <li>multi_slice</li> <li>single_slice</li> </ul> </li> <li>lsm<ul> <li>cli</li> <li>mosaic</li> </ul> </li> <li>psoct<ul> <li>_utils</li> <li>cli</li> <li>multi_slice</li> <li>single_volume</li> </ul> </li> <li>wk<ul> <li>cli</li> <li>webknossos_annotation</li> </ul> </li> </ul> </li> <li>utils<ul> <li>j2k</li> <li>math</li> <li>orientation</li> <li>unit</li> <li>zarr</li> </ul> </li> </ul>"},{"location":"contribute/","title":"Contribute","text":"<p>If you find an issue with this documentation please file an issue or submit a pull request on the linc-convert repository.</p> <p>If you would like to contribute to the LINC documentation and render the documentation locally as you make edits, please follow the steps below:</p> <ol> <li>Fork the linc-convert repository and clone it to your computer.</li> <li>Set up a Python environment with the dependencies in the requirements.txt file.</li> <li>Within the Python environment, run <code>mkdocs serve</code>.  This will build the website and start a local webserver (e.g. at http://127.0.0.1:8000) with your documentation.</li> <li>As you continue to edit the markdown files or configuration file, your documentation will be automatically re-built and rendered locally.</li> <li>Commit your changes and submit a pull request.</li> </ol>"},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/","title":"Api","text":"<ul> <li>Welcome</li> <li>Contribute</li> <li>About</li> <li>cli</li> <li>modalities<ul> <li>df<ul> <li>cli</li> <li>multi_slice</li> <li>single_slice</li> </ul> </li> <li>lsm<ul> <li>cli</li> <li>mosaic</li> </ul> </li> <li>psoct<ul> <li>_utils</li> <li>cli</li> <li>multi_slice</li> <li>single_volume</li> </ul> </li> <li>wk<ul> <li>cli</li> <li>webknossos_annotation</li> </ul> </li> </ul> </li> <li>utils<ul> <li>j2k</li> <li>math</li> <li>orientation</li> <li>unit</li> <li>zarr</li> </ul> </li> </ul>"},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/cli/","title":"Cli","text":""},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/cli/#linc_convert.cli","title":"linc_convert.cli","text":"<p>Root command line entry point.</p>"},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/modalities/__init__/","title":"init","text":""},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/modalities/__init__/#linc_convert.modalities","title":"linc_convert.modalities","text":"<p>Converters for all imaging modalities.</p>"},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/modalities/df/__init__/","title":"init","text":""},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/modalities/df/__init__/#linc_convert.modalities.df","title":"linc_convert.modalities.df","text":"<p>Dark Field microscopy converters.</p>"},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/modalities/df/cli/","title":"Cli","text":""},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/modalities/df/cli/#linc_convert.modalities.df.cli","title":"linc_convert.modalities.df.cli","text":"<p>Entry-points for Dark Field microscopy converter.</p>"},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/modalities/df/multi_slice/","title":"Multi slice","text":""},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/modalities/df/multi_slice/#linc_convert.modalities.df.multi_slice","title":"linc_convert.modalities.df.multi_slice","text":"<p>Convert JPEG2000 files generated by MBF-Neurolucida into a OME-ZARR pyramid.</p> <p>We do not recompute the image pyramid but instead reuse the JPEG2000 levels (obtained by wavelet transform).</p>"},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/modalities/df/multi_slice/#linc_convert.modalities.df.multi_slice.convert","title":"convert","text":"<pre><code>convert(inp, out=None, *, chunk=1024, compressor='blosc', compressor_opt='{}', max_load=16384, nii=False, orientation='coronal', center=True, thickness=None)\n</code></pre> <p>Convert JPEG2000 files generated by MBF-Neurolucida into a Zarr pyramid.</p> <p>It does not recompute the image pyramid but instead reuse the JPEG2000 levels (obtained by wavelet transform).</p> <p>This command converts a batch of slices and stacks them together into a single 3D Zarr.</p> Orientation <p>The anatomical orientation of the slice is given in terms of RAS axes.</p> <p>It is a combination of two letters from the set <code>{\"L\", \"R\", \"A\", \"P\", \"I\", \"S\"}</code>, where</p> <ul> <li>the first letter corresponds to the horizontal dimension and   indicates the anatomical meaning of the right of the jp2 image,</li> <li>the second letter corresponds to the vertical dimension and   indicates the anatomical meaning of the bottom of the jp2 image,</li> <li>the third letter corresponds to the slice dimension and   indicates the anatomical meaninff of the end of the stack.</li> </ul> <p>We also provide the aliases</p> <ul> <li><code>\"coronal\"</code> == <code>\"LI\"</code></li> <li><code>\"axial\"</code> == <code>\"LP\"</code></li> <li><code>\"sagittal\"</code> == <code>\"PI\"</code></li> </ul> <p>The orientation flag is only useful when converting to nifti-zarr.</p> <p>Parameters:</p> Name Type Description Default <code>inp</code> <code>list[str]</code> <p>Path to the input slices</p> required <code>out</code> <code>str | None</code> <p>Path to the output Zarr directory [.ome.zarr] <code>None</code> <code>chunk</code> <code>int</code> <p>Output chunk size</p> <code>1024</code> <code>compressor</code> <code>(blosc, zlib, raw)</code> <p>Compression method</p> <code>blosc</code> <code>compressor_opt</code> <code>str</code> <p>Compression options</p> <code>'{}'</code> <code>max_load</code> <code>int</code> <p>Maximum input chunk size</p> <code>16384</code> <code>nii</code> <code>bool</code> <p>Convert to nifti-zarr. True if path ends in \".nii.zarr\"</p> <code>False</code> <code>orientation</code> <code>str</code> <p>Orientation of the slice</p> <code>'coronal'</code> <code>center</code> <code>bool</code> <p>Set RAS[0, 0, 0] at FOV center</p> <code>True</code> <code>thickness</code> <code>float | None</code> <p>Slice thickness</p> <code>None</code>"},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/modalities/df/single_slice/","title":"Single slice","text":""},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/modalities/df/single_slice/#linc_convert.modalities.df.single_slice","title":"linc_convert.modalities.df.single_slice","text":"<p>Converts JPEG2000 files generated by MBF-Neurolucida into a OME-ZARR pyramid.</p> <p>It does not recompute the image pyramid but instead reuse the JPEG2000 levels (obtained by wavelet transform).</p>"},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/modalities/df/single_slice/#linc_convert.modalities.df.single_slice.convert","title":"convert","text":"<pre><code>convert(inp, out=None, *, chunk=1024, compressor='blosc', compressor_opt='{}', max_load=16384, nii=False, orientation='coronal', center=True, thickness=None)\n</code></pre> <p>Convert JPEG2000 files generated by MBF-Neurolucida into a Zarr pyramid.</p> <p>It does not recompute the image pyramid but instead reuse the JPEG2000 levels (obtained by wavelet transform).</p> Orientation <p>The anatomical orientation of the slice is given in terms of RAS axes.</p> <p>It is a combination of two letters from the set <code>{\"L\", \"R\", \"A\", \"P\", \"I\", \"S\"}</code>, where</p> <ul> <li>the first letter corresponds to the horizontal dimension and     indicates the anatomical meaning of the right of the jp2 image,</li> <li>the second letter corresponds to the vertical dimension and     indicates the anatomical meaning of the bottom of the jp2 image.</li> </ul> <p>We also provide the aliases</p> <ul> <li><code>\"coronal\"</code> == <code>\"LI\"</code></li> <li><code>\"axial\"</code> == <code>\"LP\"</code></li> <li><code>\"sagittal\"</code> == <code>\"PI\"</code></li> </ul> <p>The orientation flag is only useful when converting to nifti-zarr.</p> <p>Parameters:</p> Name Type Description Default <code>inp</code> <code>str</code> <p>Path to the input JP2 file</p> required <code>out</code> <code>str | None</code> <p>Path to the output Zarr directory [.ome.zarr] <code>None</code> <code>chunk</code> <code>int</code> <p>Output chunk size</p> <code>1024</code> <code>compressor</code> <code>(blosc, zlib, raw)</code> <p>Compression method</p> <code>blosc</code> <code>compressor_opt</code> <code>str</code> <p>Compression options</p> <code>'{}'</code> <code>max_load</code> <code>int</code> <p>Maximum input chunk size</p> <code>16384</code> <code>nii</code> <code>bool</code> <p>Convert to nifti-zarr. True if path ends in \".nii.zarr\"</p> <code>False</code> <code>orientation</code> <code>str</code> <p>Orientation of the slice</p> <code>'coronal'</code> <code>center</code> <code>bool</code> <p>Set RAS[0, 0, 0] at FOV center</p> <code>True</code> <code>thickness</code> <code>float | None</code> <p>Slice thickness</p> <code>None</code>"},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/modalities/lsm/__init__/","title":"init","text":""},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/modalities/lsm/__init__/#linc_convert.modalities.lsm","title":"linc_convert.modalities.lsm","text":"<p>Light Sheet Microscopy converters.</p>"},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/modalities/lsm/cli/","title":"Cli","text":""},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/modalities/lsm/cli/#linc_convert.modalities.lsm.cli","title":"linc_convert.modalities.lsm.cli","text":"<p>Entry-points for Dark Field microscopy converter.</p>"},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/modalities/lsm/mosaic/","title":"Mosaic","text":""},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/modalities/lsm/mosaic/#linc_convert.modalities.lsm.mosaic","title":"linc_convert.modalities.lsm.mosaic","text":"<p>Convert a collection of tiff files generated by the LSM pipeline into a Zarr.</p> <p>Example input files can be found at https://lincbrain.org/dandiset/000004/0.240319.1924/files?location=derivatives%2F</p>"},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/modalities/lsm/mosaic/#linc_convert.modalities.lsm.mosaic.convert","title":"convert","text":"<pre><code>convert(inp, out=None, *, chunk=128, compressor='blosc', compressor_opt='{}', max_load=512, nii=False, orientation='coronal', center=True, thickness=None, voxel_size=(1, 1, 1))\n</code></pre> <p>Convert a collection of tiff files generated by the LSM pipeline into ZARR.</p> Orientation <p>The anatomical orientation of the slice is given in terms of RAS axes.</p> <p>It is a combination of two letters from the set <code>{\"L\", \"R\", \"A\", \"P\", \"I\", \"S\"}</code>, where</p> <ul> <li>the first letter corresponds to the horizontal dimension and     indicates the anatomical meaning of the right of the jp2 image,</li> <li>the second letter corresponds to the vertical dimension and     indicates the anatomical meaning of the bottom of the jp2 image.</li> </ul> <p>We also provide the aliases</p> <ul> <li><code>\"coronal\"</code> == <code>\"LI\"</code></li> <li><code>\"axial\"</code> == <code>\"LP\"</code></li> <li><code>\"sagittal\"</code> == <code>\"PI\"</code></li> </ul> <p>The orientation flag is only useful when converting to nifti-zarr.</p> <p>Parameters:</p> Name Type Description Default <code>inp</code> <code>str</code> <p>Path to the root directory, which contains a collection of subfolders named <code>*_z{:02d}_y{:02d}*</code>, each containing a collection of files named <code>*_plane{:03d}_c{:d}.tiff</code>.</p> required <code>out</code> <code>str</code> <p>Path to the output Zarr directory [.ome.zarr] <code>None</code> <code>chunk</code> <code>int</code> <p>Output chunk size</p> <code>128</code> <code>compressor</code> <code>(blosc, zlib, raw)</code> <p>Compression method</p> <code>blosc</code> <code>compressor_opt</code> <code>str</code> <p>Compression options</p> <code>'{}'</code> <code>max_load</code> <code>int</code> <p>Maximum input chunk size when building pyramid</p> <code>512</code> <code>nii</code> <code>bool</code> <p>Convert to nifti-zarr. True if path ends in \".nii.zarr\".</p> <code>False</code> <code>orientation</code> <code>str</code> <p>Orientation of the slice</p> <code>'coronal'</code> <code>center</code> <code>bool</code> <p>Set RAS[0, 0, 0] at FOV center</p> <code>True</code> <code>voxel_size</code> <code>list[float]</code> <p>Voxel size along the X, Y and Z dimension, in micron.</p> <code>(1, 1, 1)</code>"},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/modalities/psoct/__init__/","title":"init","text":""},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/modalities/psoct/__init__/#linc_convert.modalities.psoct","title":"linc_convert.modalities.psoct","text":"<p>Polarization-sensitive optical coherence tomography converters.</p>"},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/modalities/psoct/_utils/","title":"utils","text":""},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/modalities/psoct/_utils/#linc_convert.modalities.psoct._utils","title":"linc_convert.modalities.psoct._utils","text":""},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/modalities/psoct/_utils/#linc_convert.modalities.psoct._utils.make_json","title":"make_json","text":"<pre><code>make_json(oct_meta)\n</code></pre> <p>Make json from OCT metadata.</p> Expected input: <p>Image medium: 60% TDE Center Wavelength: 1294.84nm Axial resolution: 4.9um Lateral resolution: 4.92um FOV: 3x3mm Voxel size: 3x3x3um Depth focus range: 225um Number of focuses: 2 Focus #: 2 Slice thickness: 450um. Number of slices: 75 Slice #:23 Modality: dBI</p>"},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/modalities/psoct/_utils/#linc_convert.modalities.psoct._utils.generate_pyramid","title":"generate_pyramid","text":"<pre><code>generate_pyramid(omz, levels=None, ndim=3, max_load=512, mode='median', no_pyramid_axis=None)\n</code></pre> <p>Generate the levels of a pyramid in an existing Zarr.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>PathLike | str</code> <p>Path to parent Zarr</p> required <code>levels</code> <code>int</code> <p>Number of additional levels to generate. By default, stop when all dimensions are smaller than their corresponding chunk size.</p> <code>None</code> <code>shard</code> <code>list[int] | bool | {auto} | None</code> <p>Shard size. * If <code>None</code>, use same shard size as the input array; * If <code>False</code>, no dot use sharding; * If <code>True</code> or <code>\"auto\"</code>, automatically find shard size; * Otherwise, use provided shard size.</p> required <code>ndim</code> <code>int</code> <p>Number of spatial dimensions.</p> <code>3</code> <code>max_load</code> <code>int</code> <p>Maximum number of voxels to load along each dimension.</p> <code>512</code> <code>mode</code> <code>(mean, median)</code> <p>Whether to use a mean or median moving window.</p> <code>\"mean\"</code> <p>Returns:</p> Name Type Description <code>shapes</code> <code>list[list[int]]</code> <p>Shapes of all levels, from finest to coarsest, including the existing top level.</p>"},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/modalities/psoct/_utils/#linc_convert.modalities.psoct._utils.write_ome_metadata","title":"write_ome_metadata","text":"<pre><code>write_ome_metadata(omz, axes, space_scale=1, time_scale=1, space_unit='micrometer', time_unit='second', name='', pyramid_aligns=2, levels=None, no_pool=None, multiscales_type='')\n</code></pre> <p>Write OME metadata into Zarr.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | PathLike</code> <p>Path to parent Zarr.</p> required <code>axes</code> <code>list[str]</code> <p>Name of each dimension, in Zarr order (t, c, z, y, x)</p> required <code>space_scale</code> <code>float | list[float]</code> <p>Finest-level voxel size, in Zarr order (z, y, x)</p> <code>1</code> <code>time_scale</code> <code>float</code> <p>Time scale</p> <code>1</code> <code>space_unit</code> <code>str</code> <p>Unit of spatial scale (assumed identical across dimensions)</p> <code>'micrometer'</code> <code>space_time</code> <code>str</code> <p>Unit of time scale</p> required <code>name</code> <code>str</code> <p>Name attribute</p> <code>''</code> <code>pyramid_aligns</code> <code>float | list[float] | {center, edge}</code> <p>Whether the pyramid construction aligns the edges or the centers of the corner voxels. If a (list of) number, assume that a moving window of that size was used.</p> <code>2</code> <code>levels</code> <code>int</code> <p>Number of existing levels. Default: find out automatically.</p> <code>None</code> <code>zarr_version</code> <code>(2, 3)</code> <p>Zarr version. If <code>None</code>, guess from existing zarr array.</p> <code>2</code>"},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/modalities/psoct/_utils/#linc_convert.modalities.psoct._utils.niftizarr_write_header","title":"niftizarr_write_header","text":"<pre><code>niftizarr_write_header(omz, shape, affine, dtype, unit=None, header=None, nifti_version=1)\n</code></pre> <p>Write NIfTI header in a NIfTI-Zarr file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>PathLike | str</code> <p>Path to parent Zarr.</p> required <code>affine</code> <code>(4, 4) matrix</code> <p>Orientation matrix.</p> required <code>shape</code> <code>list[int]</code> <p>Array shape, in NIfTI order (x, y, z, t, c).</p> required <code>dtype</code> <code>dtype | str</code> <p>Data type.</p> required <code>unit</code> <code>(micron, mm)</code> <p>World unit.</p> <code>\"micron\"</code> <code>header</code> <code>Nifti1Header | Nifti2Header</code> <p>Pre-instantiated header.</p> <code>None</code> <code>zarr_version</code> <code>int</code> <p>Zarr version.</p> <code>3</code>"},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/modalities/psoct/cli/","title":"Cli","text":""},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/modalities/psoct/cli/#linc_convert.modalities.psoct.cli","title":"linc_convert.modalities.psoct.cli","text":"<p>Entry-points for polarization-sensitive optical coherence tomography converter.</p>"},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/modalities/psoct/multi_slice/","title":"Multi slice","text":""},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/modalities/psoct/multi_slice/#linc_convert.modalities.psoct.multi_slice","title":"linc_convert.modalities.psoct.multi_slice","text":"<p>Matlab to OME-Zarr.</p> <p>Converts Matlab files generated by the MGH in-house OCT pipeline into a OME-ZARR pyramid.</p>"},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/modalities/psoct/multi_slice/#linc_convert.modalities.psoct.multi_slice.convert","title":"convert","text":"<pre><code>convert(inp, out=None, *, key=None, meta=None, chunk=128, compressor='blosc', compressor_opt='{}', max_load=128, max_levels=5, no_pool=None, nii=False, orientation='RAS', center=True, dtype=None)\n</code></pre> <p>Matlab to OME-Zarr.</p> <p>Convert OCT volumes in raw matlab files into a pyramidal OME-ZARR (or NIfTI-Zarr) hierarchy.</p> <p>This command assumes that each slice in a volume is stored in a different mat file. All slices must have the same shape, and will be concatenated into a 3D Zarr.</p> <p>Parameters:</p> Name Type Description Default <code>inp</code> <code>list[str]</code> <p>Path to the input mat file</p> required <code>out</code> <code>Optional[str]</code> <p>Path to the output Zarr directory [.ome.zarr] <code>None</code> <code>key</code> <code>Optional[str]</code> <p>Key of the array to be extracted, default to first key found</p> <code>None</code> <code>meta</code> <code>str</code> <p>Path to the metadata file</p> <code>None</code> <code>chunk</code> <code>int</code> <p>Output chunk size</p> <code>128</code> <code>compressor</code> <code>(blosc, zlib, raw)</code> <p>Compression method</p> <code>blosc</code> <code>compressor_opt</code> <code>str</code> <p>Compression options</p> <code>'{}'</code> <code>max_load</code> <code>int</code> <p>Maximum input chunk size</p> <code>128</code> <code>max_levels</code> <code>int</code> <p>Maximum number of pyramid levels</p> <code>5</code> <code>no_pool</code> <code>Optional[int]</code> <p>Index of dimension to not pool when building pyramid.</p> <code>None</code> <code>nii</code> <code>bool</code> <p>Convert to nifti-zarr. True if path ends in \".nii.zarr\"</p> <code>False</code> <code>orientation</code> <code>str</code> <p>Orientation of the volume</p> <code>'RAS'</code> <code>center</code> <code>bool</code> <p>Set RAS[0, 0, 0] at FOV center</p> <code>True</code> <code>dtype</code> <code>str | None</code> <p>Data type to write into</p> <code>None</code>"},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/modalities/psoct/single_volume/","title":"Single volume","text":""},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/modalities/psoct/single_volume/#linc_convert.modalities.psoct.single_volume","title":"linc_convert.modalities.psoct.single_volume","text":"<p>Matlab to OME-Zarr.</p> <p>Converts Matlab files generated by the MGH in-house OCT pipeline into a OME-ZARR pyramid.</p>"},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/modalities/psoct/single_volume/#linc_convert.modalities.psoct.single_volume.convert","title":"convert","text":"<pre><code>convert(inp, out=None, *, key=None, meta=None, chunk=128, compressor='blosc', compressor_opt='{}', max_load=128, max_levels=5, no_pool=None, nii=False, orientation='RAS', center=True)\n</code></pre> <p>Matlab to OME-Zarr.</p> <p>Convert OCT volumes in raw matlab files into a pyramidal OME-ZARR (or NIfTI-Zarr) hierarchy.</p> <p>Parameters:</p> Name Type Description Default <code>inp</code> <code>str</code> <p>Path to the input mat file</p> required <code>out</code> <code>Optional[str]</code> <p>Path to the output Zarr directory [.ome.zarr] <code>None</code> <code>key</code> <code>Optional[str]</code> <p>Key of the array to be extracted, default to first key found</p> <code>None</code> <code>meta</code> <code>str</code> <p>Path to the metadata file</p> <code>None</code> <code>chunk</code> <code>int</code> <p>Output chunk size</p> <code>128</code> <code>compressor</code> <code>(blosc, zlib, raw)</code> <p>Compression method</p> <code>blosc</code> <code>compressor_opt</code> <code>str</code> <p>Compression options</p> <code>'{}'</code> <code>max_load</code> <code>int</code> <p>Maximum input chunk size</p> <code>128</code> <code>max_levels</code> <code>int</code> <p>Maximum number of pyramid levels</p> <code>5</code> <code>no_pool</code> <code>Optional[int]</code> <p>Index of dimension to not pool when building pyramid</p> <code>None</code> <code>nii</code> <code>bool</code> <p>Convert to nifti-zarr. True if path ends in \".nii.zarr\"</p> <code>False</code> <code>orientation</code> <code>str</code> <p>Orientation of the volume</p> <code>'RAS'</code> <code>center</code> <code>bool</code> <p>Set RAS[0, 0, 0] at FOV center</p> <code>True</code>"},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/modalities/wk/__init__/","title":"init","text":""},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/modalities/wk/__init__/#linc_convert.modalities.wk","title":"linc_convert.modalities.wk","text":"<p>Webknossos annotation converters.</p>"},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/modalities/wk/cli/","title":"Cli","text":""},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/modalities/wk/cli/#linc_convert.modalities.wk.cli","title":"linc_convert.modalities.wk.cli","text":"<p>Entry-points for Webknossos annotation converter.</p>"},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/modalities/wk/webknossos_annotation/","title":"Webknossos annotation","text":""},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/modalities/wk/webknossos_annotation/#linc_convert.modalities.wk.webknossos_annotation","title":"linc_convert.modalities.wk.webknossos_annotation","text":"<p>Convert annotation downloaded from webknossos into ome.zarr format.</p>"},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/modalities/wk/webknossos_annotation/#linc_convert.modalities.wk.webknossos_annotation.convert","title":"convert","text":"<pre><code>convert(wkw_dir=None, ome_dir=None, out=None, dic=None, *, chunk=1024, compressor='blosc', compressor_opt='{}', max_load=16384)\n</code></pre> <p>Convert annotations (in .wkw format) from webknossos to ome.zarr format.</p> <p>This script converts annotations from webknossos, following the czyx direction, to the ome.zarr format. The conversion ensures that the annotations match the underlying dataset.</p> <p>Parameters:</p> Name Type Description Default <code>wkw_dir</code> <code>str</code> <p>Path to the unzipped manual annotation folder downloaded from webknossos in .wkw format. For example: .../annotation_folder/data_Volume.</p> <code>None</code> <code>ome_dir</code> <code>str</code> <p>Path to the underlying ome.zarr dataset, following the BIDS naming standard.</p> <code>None</code> <code>out</code> <code>str</code> <p>Path to the output directory for saving the converted ome.zarr. The ome.zarr file name is generated automatically based on ome_dir and the initials of the annotator.</p> <code>None</code> <code>dic</code> <code>dict</code> <p>A dictionary mapping annotation values to the following standard values if annotation doesn't match the standard. The dictionary should be in single quotes, with keys in double quotes, for example: dic = '{\"2\": 1, \"4\": 2}'. The standard values are: - 0: background - 1: Light Bundle - 2: Moderate Bundle - 3: Dense Bundle - 4: Light Terminal - 5: Moderate Terminal - 6: Dense Terminal - 7: Single Fiber</p> <code>None</code>"},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/modalities/wk/webknossos_annotation/#linc_convert.modalities.wk.webknossos_annotation.get_mask_name","title":"get_mask_name","text":"<pre><code>get_mask_name(level)\n</code></pre> <p>Return the name of the mask for a given resolution level.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>int</code> <p>The resolution level for which to return the mask name.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The name of the mask for the given level.</p>"},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/modalities/wk/webknossos_annotation/#linc_convert.modalities.wk.webknossos_annotation.cal_distance","title":"cal_distance","text":"<pre><code>cal_distance(img)\n</code></pre> <p>Return the distance of non-zero values to the top border.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>ndarray</code> <p>The array to calculate distance of object inside to border</p> required <p>Returns:</p> Type Description <code>int</code> <p>The distance of non-zero to the top border</p>"},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/modalities/wk/webknossos_annotation/#linc_convert.modalities.wk.webknossos_annotation.find_borders","title":"find_borders","text":"<pre><code>find_borders(img)\n</code></pre> <p>Return the distances of non-zero values to four borders.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>ndarray</code> <p>The array to calculate distance of object inside to border</p> required <p>Returns:</p> Type Description <code>int</code> <p>The distance of non-zero values to four borders</p>"},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/utils/__init__/","title":"init","text":""},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/utils/__init__/#linc_convert.utils","title":"linc_convert.utils","text":"<p>Various utilities.</p>"},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/utils/j2k/","title":"J2k","text":""},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/utils/j2k/#linc_convert.utils.j2k","title":"linc_convert.utils.j2k","text":"<p>Utilities for JPEG2000 files.</p>"},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/utils/j2k/#linc_convert.utils.j2k.WrappedJ2K","title":"WrappedJ2K  <code>dataclass</code>","text":"<pre><code>WrappedJ2K(j2k, level=0, channel_first=True)\n</code></pre> <p>Array-like wrapper around a JPEG2000 object.</p> <p>A wrapper around the J2K object at any resolution level, and with virtual transposition of the axes into [C, H, W] order.</p> <p>The resulting object can be sliced, but each index must be a <code>slice</code> (dropping axes using integer indices or adding axes using <code>None</code> indices is forbidden).</p> <p>The point is to ensure that the zarr writer only loads chunk-sized data.</p> <p>Parameters:</p> Name Type Description Default <code>j2k</code> <code>Jp2k</code> <p>The JPEG2000 object.</p> required <code>level</code> <code>int</code> <p>Resolution level to map (highest resolution = 0).</p> <code>0</code> <code>channel_first</code> <code>bool</code> <p>Return an array with shape (C, H, W) instead of (H, W, C) when there is a channel dimension.</p> <code>True</code>"},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/utils/j2k/#linc_convert.utils.j2k.WrappedJ2K.shape","title":"shape  <code>property</code>","text":"<pre><code>shape\n</code></pre> <p>Shape of the current level.</p>"},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/utils/j2k/#linc_convert.utils.j2k.WrappedJ2K.dtype","title":"dtype  <code>property</code>","text":"<pre><code>dtype\n</code></pre> <p>Data type of the wrapped image.</p>"},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/utils/j2k/#linc_convert.utils.j2k.WrappedJ2K.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(index)\n</code></pre> <p>Multidimensional slicing of the wrapped array.</p>"},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/utils/j2k/#linc_convert.utils.j2k.get_pixelsize","title":"get_pixelsize","text":"<pre><code>get_pixelsize(j2k)\n</code></pre> <p>Read pixelsize from the JPEG2000 file.</p>"},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/utils/math/","title":"Math","text":""},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/utils/math/#linc_convert.utils.math","title":"linc_convert.utils.math","text":"<p>Math utilities.</p>"},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/utils/math/#linc_convert.utils.math.ceildiv","title":"ceildiv","text":"<pre><code>ceildiv(x, y)\n</code></pre> <p>Ceil of ratio of two numbers.</p>"},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/utils/math/#linc_convert.utils.math.floordiv","title":"floordiv","text":"<pre><code>floordiv(x, y)\n</code></pre> <p>Floor of ratio of two numbers.</p>"},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/utils/orientation/","title":"Orientation","text":""},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/utils/orientation/#linc_convert.utils.orientation","title":"linc_convert.utils.orientation","text":"<p>Orientation of an array of voxels with respect to world space.</p>"},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/utils/orientation/#linc_convert.utils.orientation.orientation_ensure_3d","title":"orientation_ensure_3d","text":"<pre><code>orientation_ensure_3d(orientation)\n</code></pre> <p>Convert an ND orientation string to a 3D orientation string.</p> <p>Parameters:</p> Name Type Description Default <code>orientation</code> <code>str</code> <p>A 2D or 3D orientation string, such as <code>\"RA\"</code> or <code>\"RAS\"</code>.</p> required <p>Returns:</p> Name Type Description <code>orientation</code> <code>str</code> <p>A 3D orientation string compatible with the input orientaition</p>"},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/utils/orientation/#linc_convert.utils.orientation.orientation_to_affine","title":"orientation_to_affine","text":"<pre><code>orientation_to_affine(orientation, vxw=1, vxh=1, vxd=1)\n</code></pre> <p>Build an affine matrix from an orientation string and voxel size.</p> <p>Parameters:</p> Name Type Description Default <code>orientation</code> <code>str</code> <p>Orientation string</p> required <code>vxw</code> <code>float</code> <p>Width voxel size</p> <code>1</code> <code>vxh</code> <code>float</code> <p>Height voxel size</p> <code>1</code> <code>vxd</code> <code>float</code> <p>Depth voxel size</p> <code>1</code> <p>Returns:</p> Name Type Description <code>affine</code> <code>(4, 4) array</code> <p>Affine orientation matrix</p>"},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/utils/orientation/#linc_convert.utils.orientation.center_affine","title":"center_affine","text":"<pre><code>center_affine(affine, shape)\n</code></pre> <p>Ensure that the center of the field-of-view has world coordinate (0,0,0).</p> <p>The input affine is NOT modified in-place</p> <p>Parameters:</p> Name Type Description Default <code>affine</code> <code>array</code> <p>Orientation affine matrix</p> required <code>shape</code> <code>list[int]</code> <p>Shape of the array of voxels</p> required <p>Returns:</p> Name Type Description <code>affine</code> <code>array</code> <p>Modified affine matrix.</p>"},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/utils/unit/","title":"Unit","text":""},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/utils/unit/#linc_convert.utils.unit","title":"linc_convert.utils.unit","text":"<p>Converts units between zarr and other specifications.</p>"},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/utils/unit/#linc_convert.utils.unit.convert_unit","title":"convert_unit","text":"<pre><code>convert_unit(value, src, dst)\n</code></pre> <p>Convert unit for a value.</p>"},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/utils/unit/#linc_convert.utils.unit.to_ome_unit","title":"to_ome_unit","text":"<pre><code>to_ome_unit(unit)\n</code></pre> <p>Convert unit to ome-zarr spec.</p>"},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/utils/unit/#linc_convert.utils.unit.to_nifti_unit","title":"to_nifti_unit","text":"<pre><code>to_nifti_unit(unit)\n</code></pre> <p>Convert unit to nifti spec.</p>"},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/utils/unit/#linc_convert.utils.unit.unit_to_scale","title":"unit_to_scale","text":"<pre><code>unit_to_scale(unit)\n</code></pre> <p>Convert unit to scale.</p>"},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/utils/zarr/","title":"Zarr","text":""},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/utils/zarr/#linc_convert.utils.zarr","title":"linc_convert.utils.zarr","text":"<p>Zarr utilities.</p>"},{"location":"/Users/kabilar/Documents/GitHub/linc-convert/docs/api/utils/zarr/#linc_convert.utils.zarr.make_compressor","title":"make_compressor","text":"<pre><code>make_compressor(name, **prm)\n</code></pre> <p>Build compressor object from name and options.</p>"},{"location":"api/cli/","title":"cli","text":""},{"location":"api/cli/#linc_convert.cli","title":"linc_convert.cli","text":"<p>Root command line entry point.</p>"},{"location":"api/modalities/__init__/","title":"modalities","text":""},{"location":"api/modalities/__init__/#linc_convert.modalities","title":"linc_convert.modalities","text":"<p>Converters for all imaging modalities.</p>"},{"location":"api/modalities/df/__init__/","title":"df","text":""},{"location":"api/modalities/df/__init__/#linc_convert.modalities.df","title":"linc_convert.modalities.df","text":"<p>Dark Field microscopy converters.</p>"},{"location":"api/modalities/df/cli/","title":"cli","text":""},{"location":"api/modalities/df/cli/#linc_convert.modalities.df.cli","title":"linc_convert.modalities.df.cli","text":"<p>Entry-points for Dark Field microscopy converter.</p>"},{"location":"api/modalities/df/multi_slice/","title":"multi_slice","text":""},{"location":"api/modalities/df/multi_slice/#linc_convert.modalities.df.multi_slice","title":"linc_convert.modalities.df.multi_slice","text":"<p>Convert JPEG2000 files generated by MBF-Neurolucida into a OME-ZARR pyramid.</p> <p>We do not recompute the image pyramid but instead reuse the JPEG2000 levels (obtained by wavelet transform).</p>"},{"location":"api/modalities/df/multi_slice/#linc_convert.modalities.df.multi_slice.convert","title":"convert","text":"<pre><code>convert(inp, out=None, *, chunk=1024, compressor='blosc', compressor_opt='{}', max_load=16384, nii=False, orientation='coronal', center=True, thickness=None)\n</code></pre> <p>Convert JPEG2000 files generated by MBF-Neurolucida into a Zarr pyramid.</p> <p>It does not recompute the image pyramid but instead reuse the JPEG2000 levels (obtained by wavelet transform).</p> <p>This command converts a batch of slices and stacks them together into a single 3D Zarr.</p> Orientation <p>The anatomical orientation of the slice is given in terms of RAS axes.</p> <p>It is a combination of two letters from the set <code>{\"L\", \"R\", \"A\", \"P\", \"I\", \"S\"}</code>, where</p> <ul> <li>the first letter corresponds to the horizontal dimension and   indicates the anatomical meaning of the right of the jp2 image,</li> <li>the second letter corresponds to the vertical dimension and   indicates the anatomical meaning of the bottom of the jp2 image,</li> <li>the third letter corresponds to the slice dimension and   indicates the anatomical meaninff of the end of the stack.</li> </ul> <p>We also provide the aliases</p> <ul> <li><code>\"coronal\"</code> == <code>\"LI\"</code></li> <li><code>\"axial\"</code> == <code>\"LP\"</code></li> <li><code>\"sagittal\"</code> == <code>\"PI\"</code></li> </ul> <p>The orientation flag is only useful when converting to nifti-zarr.</p> <p>Parameters:</p> Name Type Description Default <code>inp</code> <code>list[str]</code> <p>Path to the input slices</p> required <code>out</code> <code>str | None</code> <p>Path to the output Zarr directory [.ome.zarr] <code>None</code> <code>chunk</code> <code>int</code> <p>Output chunk size</p> <code>1024</code> <code>compressor</code> <code>(blosc, zlib, raw)</code> <p>Compression method</p> <code>blosc</code> <code>compressor_opt</code> <code>str</code> <p>Compression options</p> <code>'{}'</code> <code>max_load</code> <code>int</code> <p>Maximum input chunk size</p> <code>16384</code> <code>nii</code> <code>bool</code> <p>Convert to nifti-zarr. True if path ends in \".nii.zarr\"</p> <code>False</code> <code>orientation</code> <code>str</code> <p>Orientation of the slice</p> <code>'coronal'</code> <code>center</code> <code>bool</code> <p>Set RAS[0, 0, 0] at FOV center</p> <code>True</code> <code>thickness</code> <code>float | None</code> <p>Slice thickness</p> <code>None</code>"},{"location":"api/modalities/df/single_slice/","title":"single_slice","text":""},{"location":"api/modalities/df/single_slice/#linc_convert.modalities.df.single_slice","title":"linc_convert.modalities.df.single_slice","text":"<p>Converts JPEG2000 files generated by MBF-Neurolucida into a OME-ZARR pyramid.</p> <p>It does not recompute the image pyramid but instead reuse the JPEG2000 levels (obtained by wavelet transform).</p>"},{"location":"api/modalities/df/single_slice/#linc_convert.modalities.df.single_slice.convert","title":"convert","text":"<pre><code>convert(inp, out=None, *, chunk=1024, compressor='blosc', compressor_opt='{}', max_load=16384, nii=False, orientation='coronal', center=True, thickness=None)\n</code></pre> <p>Convert JPEG2000 files generated by MBF-Neurolucida into a Zarr pyramid.</p> <p>It does not recompute the image pyramid but instead reuse the JPEG2000 levels (obtained by wavelet transform).</p> Orientation <p>The anatomical orientation of the slice is given in terms of RAS axes.</p> <p>It is a combination of two letters from the set <code>{\"L\", \"R\", \"A\", \"P\", \"I\", \"S\"}</code>, where</p> <ul> <li>the first letter corresponds to the horizontal dimension and     indicates the anatomical meaning of the right of the jp2 image,</li> <li>the second letter corresponds to the vertical dimension and     indicates the anatomical meaning of the bottom of the jp2 image.</li> </ul> <p>We also provide the aliases</p> <ul> <li><code>\"coronal\"</code> == <code>\"LI\"</code></li> <li><code>\"axial\"</code> == <code>\"LP\"</code></li> <li><code>\"sagittal\"</code> == <code>\"PI\"</code></li> </ul> <p>The orientation flag is only useful when converting to nifti-zarr.</p> <p>Parameters:</p> Name Type Description Default <code>inp</code> <code>str</code> <p>Path to the input JP2 file</p> required <code>out</code> <code>str | None</code> <p>Path to the output Zarr directory [.ome.zarr] <code>None</code> <code>chunk</code> <code>int</code> <p>Output chunk size</p> <code>1024</code> <code>compressor</code> <code>(blosc, zlib, raw)</code> <p>Compression method</p> <code>blosc</code> <code>compressor_opt</code> <code>str</code> <p>Compression options</p> <code>'{}'</code> <code>max_load</code> <code>int</code> <p>Maximum input chunk size</p> <code>16384</code> <code>nii</code> <code>bool</code> <p>Convert to nifti-zarr. True if path ends in \".nii.zarr\"</p> <code>False</code> <code>orientation</code> <code>str</code> <p>Orientation of the slice</p> <code>'coronal'</code> <code>center</code> <code>bool</code> <p>Set RAS[0, 0, 0] at FOV center</p> <code>True</code> <code>thickness</code> <code>float | None</code> <p>Slice thickness</p> <code>None</code>"},{"location":"api/modalities/lsm/__init__/","title":"lsm","text":""},{"location":"api/modalities/lsm/__init__/#linc_convert.modalities.lsm","title":"linc_convert.modalities.lsm","text":"<p>Light Sheet Microscopy converters.</p>"},{"location":"api/modalities/lsm/cli/","title":"cli","text":""},{"location":"api/modalities/lsm/cli/#linc_convert.modalities.lsm.cli","title":"linc_convert.modalities.lsm.cli","text":"<p>Entry-points for Dark Field microscopy converter.</p>"},{"location":"api/modalities/lsm/mosaic/","title":"mosaic","text":""},{"location":"api/modalities/lsm/mosaic/#linc_convert.modalities.lsm.mosaic","title":"linc_convert.modalities.lsm.mosaic","text":"<p>Convert a collection of tiff files generated by the LSM pipeline into a Zarr.</p> <p>Example input files can be found at https://lincbrain.org/dandiset/000004/0.240319.1924/files?location=derivatives%2F</p>"},{"location":"api/modalities/lsm/mosaic/#linc_convert.modalities.lsm.mosaic.convert","title":"convert","text":"<pre><code>convert(inp, out=None, *, chunk=128, compressor='blosc', compressor_opt='{}', max_load=512, nii=False, orientation='coronal', center=True, thickness=None, voxel_size=(1, 1, 1))\n</code></pre> <p>Convert a collection of tiff files generated by the LSM pipeline into ZARR.</p> Orientation <p>The anatomical orientation of the slice is given in terms of RAS axes.</p> <p>It is a combination of two letters from the set <code>{\"L\", \"R\", \"A\", \"P\", \"I\", \"S\"}</code>, where</p> <ul> <li>the first letter corresponds to the horizontal dimension and     indicates the anatomical meaning of the right of the jp2 image,</li> <li>the second letter corresponds to the vertical dimension and     indicates the anatomical meaning of the bottom of the jp2 image.</li> </ul> <p>We also provide the aliases</p> <ul> <li><code>\"coronal\"</code> == <code>\"LI\"</code></li> <li><code>\"axial\"</code> == <code>\"LP\"</code></li> <li><code>\"sagittal\"</code> == <code>\"PI\"</code></li> </ul> <p>The orientation flag is only useful when converting to nifti-zarr.</p> <p>Parameters:</p> Name Type Description Default <code>inp</code> <code>str</code> <p>Path to the root directory, which contains a collection of subfolders named <code>*_z{:02d}_y{:02d}*</code>, each containing a collection of files named <code>*_plane{:03d}_c{:d}.tiff</code>.</p> required <code>out</code> <code>str</code> <p>Path to the output Zarr directory [.ome.zarr] <code>None</code> <code>chunk</code> <code>int</code> <p>Output chunk size</p> <code>128</code> <code>compressor</code> <code>(blosc, zlib, raw)</code> <p>Compression method</p> <code>blosc</code> <code>compressor_opt</code> <code>str</code> <p>Compression options</p> <code>'{}'</code> <code>max_load</code> <code>int</code> <p>Maximum input chunk size when building pyramid</p> <code>512</code> <code>nii</code> <code>bool</code> <p>Convert to nifti-zarr. True if path ends in \".nii.zarr\".</p> <code>False</code> <code>orientation</code> <code>str</code> <p>Orientation of the slice</p> <code>'coronal'</code> <code>center</code> <code>bool</code> <p>Set RAS[0, 0, 0] at FOV center</p> <code>True</code> <code>voxel_size</code> <code>list[float]</code> <p>Voxel size along the X, Y and Z dimension, in micron.</p> <code>(1, 1, 1)</code>"},{"location":"api/modalities/psoct/__init__/","title":"psoct","text":""},{"location":"api/modalities/psoct/__init__/#linc_convert.modalities.psoct","title":"linc_convert.modalities.psoct","text":"<p>Polarization-sensitive optical coherence tomography converters.</p>"},{"location":"api/modalities/psoct/_utils/","title":"_utils","text":""},{"location":"api/modalities/psoct/_utils/#linc_convert.modalities.psoct._utils","title":"linc_convert.modalities.psoct._utils","text":""},{"location":"api/modalities/psoct/_utils/#linc_convert.modalities.psoct._utils.make_json","title":"make_json","text":"<pre><code>make_json(oct_meta)\n</code></pre> <p>Make json from OCT metadata.</p> Expected input: <p>Image medium: 60% TDE Center Wavelength: 1294.84nm Axial resolution: 4.9um Lateral resolution: 4.92um FOV: 3x3mm Voxel size: 3x3x3um Depth focus range: 225um Number of focuses: 2 Focus #: 2 Slice thickness: 450um. Number of slices: 75 Slice #:23 Modality: dBI</p>"},{"location":"api/modalities/psoct/_utils/#linc_convert.modalities.psoct._utils.generate_pyramid","title":"generate_pyramid","text":"<pre><code>generate_pyramid(omz, levels=None, ndim=3, max_load=512, mode='median', no_pyramid_axis=None)\n</code></pre> <p>Generate the levels of a pyramid in an existing Zarr.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>PathLike | str</code> <p>Path to parent Zarr</p> required <code>levels</code> <code>int</code> <p>Number of additional levels to generate. By default, stop when all dimensions are smaller than their corresponding chunk size.</p> <code>None</code> <code>shard</code> <code>list[int] | bool | {auto} | None</code> <p>Shard size. * If <code>None</code>, use same shard size as the input array; * If <code>False</code>, no dot use sharding; * If <code>True</code> or <code>\"auto\"</code>, automatically find shard size; * Otherwise, use provided shard size.</p> required <code>ndim</code> <code>int</code> <p>Number of spatial dimensions.</p> <code>3</code> <code>max_load</code> <code>int</code> <p>Maximum number of voxels to load along each dimension.</p> <code>512</code> <code>mode</code> <code>(mean, median)</code> <p>Whether to use a mean or median moving window.</p> <code>\"mean\"</code> <p>Returns:</p> Name Type Description <code>shapes</code> <code>list[list[int]]</code> <p>Shapes of all levels, from finest to coarsest, including the existing top level.</p>"},{"location":"api/modalities/psoct/_utils/#linc_convert.modalities.psoct._utils.write_ome_metadata","title":"write_ome_metadata","text":"<pre><code>write_ome_metadata(omz, axes, space_scale=1, time_scale=1, space_unit='micrometer', time_unit='second', name='', pyramid_aligns=2, levels=None, no_pool=None, multiscales_type='')\n</code></pre> <p>Write OME metadata into Zarr.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | PathLike</code> <p>Path to parent Zarr.</p> required <code>axes</code> <code>list[str]</code> <p>Name of each dimension, in Zarr order (t, c, z, y, x)</p> required <code>space_scale</code> <code>float | list[float]</code> <p>Finest-level voxel size, in Zarr order (z, y, x)</p> <code>1</code> <code>time_scale</code> <code>float</code> <p>Time scale</p> <code>1</code> <code>space_unit</code> <code>str</code> <p>Unit of spatial scale (assumed identical across dimensions)</p> <code>'micrometer'</code> <code>space_time</code> <code>str</code> <p>Unit of time scale</p> required <code>name</code> <code>str</code> <p>Name attribute</p> <code>''</code> <code>pyramid_aligns</code> <code>float | list[float] | {center, edge}</code> <p>Whether the pyramid construction aligns the edges or the centers of the corner voxels. If a (list of) number, assume that a moving window of that size was used.</p> <code>2</code> <code>levels</code> <code>int</code> <p>Number of existing levels. Default: find out automatically.</p> <code>None</code> <code>zarr_version</code> <code>(2, 3)</code> <p>Zarr version. If <code>None</code>, guess from existing zarr array.</p> <code>2</code>"},{"location":"api/modalities/psoct/_utils/#linc_convert.modalities.psoct._utils.niftizarr_write_header","title":"niftizarr_write_header","text":"<pre><code>niftizarr_write_header(omz, shape, affine, dtype, unit=None, header=None, nifti_version=1)\n</code></pre> <p>Write NIfTI header in a NIfTI-Zarr file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>PathLike | str</code> <p>Path to parent Zarr.</p> required <code>affine</code> <code>(4, 4) matrix</code> <p>Orientation matrix.</p> required <code>shape</code> <code>list[int]</code> <p>Array shape, in NIfTI order (x, y, z, t, c).</p> required <code>dtype</code> <code>dtype | str</code> <p>Data type.</p> required <code>unit</code> <code>(micron, mm)</code> <p>World unit.</p> <code>\"micron\"</code> <code>header</code> <code>Nifti1Header | Nifti2Header</code> <p>Pre-instantiated header.</p> <code>None</code> <code>zarr_version</code> <code>int</code> <p>Zarr version.</p> <code>3</code>"},{"location":"api/modalities/psoct/cli/","title":"cli","text":""},{"location":"api/modalities/psoct/cli/#linc_convert.modalities.psoct.cli","title":"linc_convert.modalities.psoct.cli","text":"<p>Entry-points for polarization-sensitive optical coherence tomography converter.</p>"},{"location":"api/modalities/psoct/multi_slice/","title":"multi_slice","text":""},{"location":"api/modalities/psoct/multi_slice/#linc_convert.modalities.psoct.multi_slice","title":"linc_convert.modalities.psoct.multi_slice","text":"<p>Matlab to OME-Zarr.</p> <p>Converts Matlab files generated by the MGH in-house OCT pipeline into a OME-ZARR pyramid.</p>"},{"location":"api/modalities/psoct/multi_slice/#linc_convert.modalities.psoct.multi_slice.convert","title":"convert","text":"<pre><code>convert(inp, out=None, *, key=None, meta=None, chunk=128, compressor='blosc', compressor_opt='{}', max_load=128, max_levels=5, no_pool=None, nii=False, orientation='RAS', center=True, dtype=None)\n</code></pre> <p>Matlab to OME-Zarr.</p> <p>Convert OCT volumes in raw matlab files into a pyramidal OME-ZARR (or NIfTI-Zarr) hierarchy.</p> <p>This command assumes that each slice in a volume is stored in a different mat file. All slices must have the same shape, and will be concatenated into a 3D Zarr.</p> <p>Parameters:</p> Name Type Description Default <code>inp</code> <code>list[str]</code> <p>Path to the input mat file</p> required <code>out</code> <code>Optional[str]</code> <p>Path to the output Zarr directory [.ome.zarr] <code>None</code> <code>key</code> <code>Optional[str]</code> <p>Key of the array to be extracted, default to first key found</p> <code>None</code> <code>meta</code> <code>str</code> <p>Path to the metadata file</p> <code>None</code> <code>chunk</code> <code>int</code> <p>Output chunk size</p> <code>128</code> <code>compressor</code> <code>(blosc, zlib, raw)</code> <p>Compression method</p> <code>blosc</code> <code>compressor_opt</code> <code>str</code> <p>Compression options</p> <code>'{}'</code> <code>max_load</code> <code>int</code> <p>Maximum input chunk size</p> <code>128</code> <code>max_levels</code> <code>int</code> <p>Maximum number of pyramid levels</p> <code>5</code> <code>no_pool</code> <code>Optional[int]</code> <p>Index of dimension to not pool when building pyramid.</p> <code>None</code> <code>nii</code> <code>bool</code> <p>Convert to nifti-zarr. True if path ends in \".nii.zarr\"</p> <code>False</code> <code>orientation</code> <code>str</code> <p>Orientation of the volume</p> <code>'RAS'</code> <code>center</code> <code>bool</code> <p>Set RAS[0, 0, 0] at FOV center</p> <code>True</code> <code>dtype</code> <code>str | None</code> <p>Data type to write into</p> <code>None</code>"},{"location":"api/modalities/psoct/single_volume/","title":"single_volume","text":""},{"location":"api/modalities/psoct/single_volume/#linc_convert.modalities.psoct.single_volume","title":"linc_convert.modalities.psoct.single_volume","text":"<p>Matlab to OME-Zarr.</p> <p>Converts Matlab files generated by the MGH in-house OCT pipeline into a OME-ZARR pyramid.</p>"},{"location":"api/modalities/psoct/single_volume/#linc_convert.modalities.psoct.single_volume.convert","title":"convert","text":"<pre><code>convert(inp, out=None, *, key=None, meta=None, chunk=128, compressor='blosc', compressor_opt='{}', max_load=128, max_levels=5, no_pool=None, nii=False, orientation='RAS', center=True)\n</code></pre> <p>Matlab to OME-Zarr.</p> <p>Convert OCT volumes in raw matlab files into a pyramidal OME-ZARR (or NIfTI-Zarr) hierarchy.</p> <p>Parameters:</p> Name Type Description Default <code>inp</code> <code>str</code> <p>Path to the input mat file</p> required <code>out</code> <code>Optional[str]</code> <p>Path to the output Zarr directory [.ome.zarr] <code>None</code> <code>key</code> <code>Optional[str]</code> <p>Key of the array to be extracted, default to first key found</p> <code>None</code> <code>meta</code> <code>str</code> <p>Path to the metadata file</p> <code>None</code> <code>chunk</code> <code>int</code> <p>Output chunk size</p> <code>128</code> <code>compressor</code> <code>(blosc, zlib, raw)</code> <p>Compression method</p> <code>blosc</code> <code>compressor_opt</code> <code>str</code> <p>Compression options</p> <code>'{}'</code> <code>max_load</code> <code>int</code> <p>Maximum input chunk size</p> <code>128</code> <code>max_levels</code> <code>int</code> <p>Maximum number of pyramid levels</p> <code>5</code> <code>no_pool</code> <code>Optional[int]</code> <p>Index of dimension to not pool when building pyramid</p> <code>None</code> <code>nii</code> <code>bool</code> <p>Convert to nifti-zarr. True if path ends in \".nii.zarr\"</p> <code>False</code> <code>orientation</code> <code>str</code> <p>Orientation of the volume</p> <code>'RAS'</code> <code>center</code> <code>bool</code> <p>Set RAS[0, 0, 0] at FOV center</p> <code>True</code>"},{"location":"api/modalities/wk/__init__/","title":"wk","text":""},{"location":"api/modalities/wk/__init__/#linc_convert.modalities.wk","title":"linc_convert.modalities.wk","text":"<p>Webknossos annotation converters.</p>"},{"location":"api/modalities/wk/cli/","title":"cli","text":""},{"location":"api/modalities/wk/cli/#linc_convert.modalities.wk.cli","title":"linc_convert.modalities.wk.cli","text":"<p>Entry-points for Webknossos annotation converter.</p>"},{"location":"api/modalities/wk/webknossos_annotation/","title":"webknossos_annotation","text":""},{"location":"api/modalities/wk/webknossos_annotation/#linc_convert.modalities.wk.webknossos_annotation","title":"linc_convert.modalities.wk.webknossos_annotation","text":"<p>Convert annotation downloaded from webknossos into ome.zarr format.</p>"},{"location":"api/modalities/wk/webknossos_annotation/#linc_convert.modalities.wk.webknossos_annotation.convert","title":"convert","text":"<pre><code>convert(wkw_dir=None, ome_dir=None, out=None, dic=None, *, chunk=1024, compressor='blosc', compressor_opt='{}', max_load=16384)\n</code></pre> <p>Convert annotations (in .wkw format) from webknossos to ome.zarr format.</p> <p>This script converts annotations from webknossos, following the czyx direction, to the ome.zarr format. The conversion ensures that the annotations match the underlying dataset.</p> <p>Parameters:</p> Name Type Description Default <code>wkw_dir</code> <code>str</code> <p>Path to the unzipped manual annotation folder downloaded from webknossos in .wkw format. For example: .../annotation_folder/data_Volume.</p> <code>None</code> <code>ome_dir</code> <code>str</code> <p>Path to the underlying ome.zarr dataset, following the BIDS naming standard.</p> <code>None</code> <code>out</code> <code>str</code> <p>Path to the output directory for saving the converted ome.zarr. The ome.zarr file name is generated automatically based on ome_dir and the initials of the annotator.</p> <code>None</code> <code>dic</code> <code>dict</code> <p>A dictionary mapping annotation values to the following standard values if annotation doesn't match the standard. The dictionary should be in single quotes, with keys in double quotes, for example: dic = '{\"2\": 1, \"4\": 2}'. The standard values are: - 0: background - 1: Light Bundle - 2: Moderate Bundle - 3: Dense Bundle - 4: Light Terminal - 5: Moderate Terminal - 6: Dense Terminal - 7: Single Fiber</p> <code>None</code>"},{"location":"api/modalities/wk/webknossos_annotation/#linc_convert.modalities.wk.webknossos_annotation.get_mask_name","title":"get_mask_name","text":"<pre><code>get_mask_name(level)\n</code></pre> <p>Return the name of the mask for a given resolution level.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>int</code> <p>The resolution level for which to return the mask name.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The name of the mask for the given level.</p>"},{"location":"api/modalities/wk/webknossos_annotation/#linc_convert.modalities.wk.webknossos_annotation.cal_distance","title":"cal_distance","text":"<pre><code>cal_distance(img)\n</code></pre> <p>Return the distance of non-zero values to the top border.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>ndarray</code> <p>The array to calculate distance of object inside to border</p> required <p>Returns:</p> Type Description <code>int</code> <p>The distance of non-zero to the top border</p>"},{"location":"api/modalities/wk/webknossos_annotation/#linc_convert.modalities.wk.webknossos_annotation.find_borders","title":"find_borders","text":"<pre><code>find_borders(img)\n</code></pre> <p>Return the distances of non-zero values to four borders.</p> <p>Parameters:</p> Name Type Description Default <code>img</code> <code>ndarray</code> <p>The array to calculate distance of object inside to border</p> required <p>Returns:</p> Type Description <code>int</code> <p>The distance of non-zero values to four borders</p>"},{"location":"api/utils/__init__/","title":"utils","text":""},{"location":"api/utils/__init__/#linc_convert.utils","title":"linc_convert.utils","text":"<p>Various utilities.</p>"},{"location":"api/utils/j2k/","title":"j2k","text":""},{"location":"api/utils/j2k/#linc_convert.utils.j2k","title":"linc_convert.utils.j2k","text":"<p>Utilities for JPEG2000 files.</p>"},{"location":"api/utils/j2k/#linc_convert.utils.j2k.WrappedJ2K","title":"WrappedJ2K  <code>dataclass</code>","text":"<pre><code>WrappedJ2K(j2k, level=0, channel_first=True)\n</code></pre> <p>Array-like wrapper around a JPEG2000 object.</p> <p>A wrapper around the J2K object at any resolution level, and with virtual transposition of the axes into [C, H, W] order.</p> <p>The resulting object can be sliced, but each index must be a <code>slice</code> (dropping axes using integer indices or adding axes using <code>None</code> indices is forbidden).</p> <p>The point is to ensure that the zarr writer only loads chunk-sized data.</p> <p>Parameters:</p> Name Type Description Default <code>j2k</code> <code>Jp2k</code> <p>The JPEG2000 object.</p> required <code>level</code> <code>int</code> <p>Resolution level to map (highest resolution = 0).</p> <code>0</code> <code>channel_first</code> <code>bool</code> <p>Return an array with shape (C, H, W) instead of (H, W, C) when there is a channel dimension.</p> <code>True</code>"},{"location":"api/utils/j2k/#linc_convert.utils.j2k.WrappedJ2K.shape","title":"shape  <code>property</code>","text":"<pre><code>shape\n</code></pre> <p>Shape of the current level.</p>"},{"location":"api/utils/j2k/#linc_convert.utils.j2k.WrappedJ2K.dtype","title":"dtype  <code>property</code>","text":"<pre><code>dtype\n</code></pre> <p>Data type of the wrapped image.</p>"},{"location":"api/utils/j2k/#linc_convert.utils.j2k.WrappedJ2K.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(index)\n</code></pre> <p>Multidimensional slicing of the wrapped array.</p>"},{"location":"api/utils/j2k/#linc_convert.utils.j2k.get_pixelsize","title":"get_pixelsize","text":"<pre><code>get_pixelsize(j2k)\n</code></pre> <p>Read pixelsize from the JPEG2000 file.</p>"},{"location":"api/utils/math/","title":"math","text":""},{"location":"api/utils/math/#linc_convert.utils.math","title":"linc_convert.utils.math","text":"<p>Math utilities.</p>"},{"location":"api/utils/math/#linc_convert.utils.math.ceildiv","title":"ceildiv","text":"<pre><code>ceildiv(x, y)\n</code></pre> <p>Ceil of ratio of two numbers.</p>"},{"location":"api/utils/math/#linc_convert.utils.math.floordiv","title":"floordiv","text":"<pre><code>floordiv(x, y)\n</code></pre> <p>Floor of ratio of two numbers.</p>"},{"location":"api/utils/orientation/","title":"orientation","text":""},{"location":"api/utils/orientation/#linc_convert.utils.orientation","title":"linc_convert.utils.orientation","text":"<p>Orientation of an array of voxels with respect to world space.</p>"},{"location":"api/utils/orientation/#linc_convert.utils.orientation.orientation_ensure_3d","title":"orientation_ensure_3d","text":"<pre><code>orientation_ensure_3d(orientation)\n</code></pre> <p>Convert an ND orientation string to a 3D orientation string.</p> <p>Parameters:</p> Name Type Description Default <code>orientation</code> <code>str</code> <p>A 2D or 3D orientation string, such as <code>\"RA\"</code> or <code>\"RAS\"</code>.</p> required <p>Returns:</p> Name Type Description <code>orientation</code> <code>str</code> <p>A 3D orientation string compatible with the input orientaition</p>"},{"location":"api/utils/orientation/#linc_convert.utils.orientation.orientation_to_affine","title":"orientation_to_affine","text":"<pre><code>orientation_to_affine(orientation, vxw=1, vxh=1, vxd=1)\n</code></pre> <p>Build an affine matrix from an orientation string and voxel size.</p> <p>Parameters:</p> Name Type Description Default <code>orientation</code> <code>str</code> <p>Orientation string</p> required <code>vxw</code> <code>float</code> <p>Width voxel size</p> <code>1</code> <code>vxh</code> <code>float</code> <p>Height voxel size</p> <code>1</code> <code>vxd</code> <code>float</code> <p>Depth voxel size</p> <code>1</code> <p>Returns:</p> Name Type Description <code>affine</code> <code>(4, 4) array</code> <p>Affine orientation matrix</p>"},{"location":"api/utils/orientation/#linc_convert.utils.orientation.center_affine","title":"center_affine","text":"<pre><code>center_affine(affine, shape)\n</code></pre> <p>Ensure that the center of the field-of-view has world coordinate (0,0,0).</p> <p>The input affine is NOT modified in-place</p> <p>Parameters:</p> Name Type Description Default <code>affine</code> <code>array</code> <p>Orientation affine matrix</p> required <code>shape</code> <code>list[int]</code> <p>Shape of the array of voxels</p> required <p>Returns:</p> Name Type Description <code>affine</code> <code>array</code> <p>Modified affine matrix.</p>"},{"location":"api/utils/unit/","title":"unit","text":""},{"location":"api/utils/unit/#linc_convert.utils.unit","title":"linc_convert.utils.unit","text":"<p>Converts units between zarr and other specifications.</p>"},{"location":"api/utils/unit/#linc_convert.utils.unit.convert_unit","title":"convert_unit","text":"<pre><code>convert_unit(value, src, dst)\n</code></pre> <p>Convert unit for a value.</p>"},{"location":"api/utils/unit/#linc_convert.utils.unit.to_ome_unit","title":"to_ome_unit","text":"<pre><code>to_ome_unit(unit)\n</code></pre> <p>Convert unit to ome-zarr spec.</p>"},{"location":"api/utils/unit/#linc_convert.utils.unit.to_nifti_unit","title":"to_nifti_unit","text":"<pre><code>to_nifti_unit(unit)\n</code></pre> <p>Convert unit to nifti spec.</p>"},{"location":"api/utils/unit/#linc_convert.utils.unit.unit_to_scale","title":"unit_to_scale","text":"<pre><code>unit_to_scale(unit)\n</code></pre> <p>Convert unit to scale.</p>"},{"location":"api/utils/zarr/","title":"zarr","text":""},{"location":"api/utils/zarr/#linc_convert.utils.zarr","title":"linc_convert.utils.zarr","text":"<p>Zarr utilities.</p>"},{"location":"api/utils/zarr/#linc_convert.utils.zarr.make_compressor","title":"make_compressor","text":"<pre><code>make_compressor(name, **prm)\n</code></pre> <p>Build compressor object from name and options.</p>"}]}